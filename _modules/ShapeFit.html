<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ShapeFit &#8212; ShapeFit v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5cb08e4e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ShapeFit</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Authors: Katayoon Ghaemi, Nils Schöneberg</span>
<span class="sd">Last updated: 14th August 2025</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">classy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.constants</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">const</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BSpline</span><span class="p">,</span>
    <span class="n">CubicSpline</span><span class="p">,</span>
    <span class="n">UnivariateSpline</span><span class="p">,</span>
    <span class="n">interp1d</span><span class="p">,</span>
    <span class="n">splrep</span><span class="p">,</span>
    <span class="n">splev</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span><span class="p">,</span> <span class="n">minimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">simpson</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">fht</span><span class="p">,</span> <span class="n">ifht</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.fftpack</span><span class="w"> </span><span class="kn">import</span> <span class="n">dst</span><span class="p">,</span> <span class="n">idst</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_peaks</span><span class="p">,</span> <span class="n">savgol_filter</span>


<span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParamsDefault</span><span class="p">)</span>


<div class="viewcode-block" id="EHclass">
<a class="viewcode-back" href="../index.html#ShapeFit.EHclass">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EHclass</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a general class that contains functions for computing</span>
<span class="sd">    the Eisenstein &amp; Hu matter power spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="EHclass.EH98">
<a class="viewcode-back" href="../index.html#ShapeFit.EHclass.EH98">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">EH98</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cosmo</span><span class="p">:</span> <span class="n">classy</span><span class="o">.</span><span class="n">Class</span><span class="p">,</span>
        <span class="n">kvector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">redshift</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">scaling_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="o">**</span><span class="n">add_args</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; EHclass.</span>
<span class="sd">        Computes the Eisenstein &amp; Hu (1998) linear matter power spectrum P(k, z).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cosmo : object: classy.Class()</span>
<span class="sd">            Cosmology object providing cosmological parameters like Omega_m(), h(), etc.</span>
<span class="sd">        kvector : array_like: np.ndarray</span>
<span class="sd">            Wavenumber values in h/Mpc.</span>
<span class="sd">        redshift : float</span>
<span class="sd">            Redshift at which the power spectrum is evaluated.</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Multiplicative factor applied to some scales (e.g., for unit conversions).</span>
<span class="sd">        **add_args : dict</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pk : ndarray: np.ndarray</span>
<span class="sd">            Linear matter power spectrum at the given redshift in (Mpc/h)^3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cdict</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">get_current_derived_parameters</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;z_d&quot;</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># z_d is the time of baryon drag</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>  <span class="c1"># h is the Hubble parameter given by h= H0/ 100 km /s /Mpc</span>
        <span class="n">H_at_z</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">Hubble</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">Omm</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">Omega_m</span><span class="p">()</span>
        <span class="n">Omb</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">Omega_b</span><span class="p">()</span>
        <span class="n">Omc</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">Omega0_cdm</span><span class="p">()</span>
        <span class="n">Omm_at_z</span> <span class="o">=</span> <span class="n">Omm</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">redshift</span><span class="p">)</span> <span class="o">**</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="n">H_at_z</span><span class="o">**</span><span class="mf">2.0</span>
        <span class="n">OmLambda_at_z</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">Omm_at_z</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">n_s</span><span class="p">()</span>  <span class="c1"># ns is the scalar tilt of primordial power spectrum</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">rs_drag</span><span class="p">()</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">scaling_factor</span>
        <span class="n">Omnu</span> <span class="o">=</span> <span class="n">Omm</span> <span class="o">-</span> <span class="n">Omb</span> <span class="o">-</span> <span class="n">Omc</span>
        <span class="n">fnu</span> <span class="o">=</span> <span class="n">Omnu</span> <span class="o">/</span> <span class="n">Omm</span>
        <span class="n">fb</span> <span class="o">=</span> <span class="n">Omb</span> <span class="o">/</span> <span class="n">Omm</span>
        <span class="n">fnub</span> <span class="o">=</span> <span class="p">(</span><span class="n">Omb</span> <span class="o">+</span> <span class="n">Omnu</span><span class="p">)</span> <span class="o">/</span> <span class="n">Omm</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">Omc</span> <span class="o">/</span> <span class="n">Omm</span>
        <span class="n">fcb</span> <span class="o">=</span> <span class="p">(</span><span class="n">Omc</span> <span class="o">+</span> <span class="n">Omb</span><span class="p">)</span> <span class="o">/</span> <span class="n">Omm</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">*</span> <span class="n">fc</span><span class="p">))</span>
        <span class="n">pcb</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">*</span> <span class="n">fcb</span><span class="p">))</span>
        <span class="n">Neff</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">Neff</span><span class="p">()</span>  <span class="c1"># the number of effective neutrino species</span>
        <span class="c1"># The neutrinos don&#39;t decouple instantasly</span>
        <span class="n">Omg</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">Omega_g</span><span class="p">()</span>
        <span class="n">Omr</span> <span class="o">=</span> <span class="n">Omg</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">Neff</span> <span class="o">*</span> <span class="p">(</span><span class="mf">7.0</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">11.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">))</span>
        <span class="n">aeq</span> <span class="o">=</span> <span class="n">Omr</span> <span class="o">/</span> <span class="p">(</span><span class="n">Omb</span> <span class="o">+</span> <span class="n">Omc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fnu</span><span class="p">)</span>
        <span class="n">zeq</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">aeq</span> <span class="o">-</span> <span class="mf">1.0</span>  <span class="c1"># redshift of equality</span>
        <span class="n">Heq</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">Hubble</span><span class="p">(</span><span class="n">zeq</span><span class="p">)</span> <span class="o">/</span> <span class="n">h</span>  <span class="c1"># Hubble constant at the equality time</span>
        <span class="n">keq</span> <span class="o">=</span> <span class="n">aeq</span> <span class="o">*</span> <span class="n">Heq</span> <span class="o">*</span> <span class="n">scaling_factor</span>  <span class="c1"># scale of matter radiation equality</span>
        <span class="n">zd</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="s2">&quot;z_d&quot;</span><span class="p">]</span>  <span class="c1"># redshift at the baryon drag epoch</span>
        <span class="n">yd</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zeq</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zd</span><span class="p">)</span>
        <span class="n">growth</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">scale_independent_growth_factor</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fnu</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">fnu</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">Nnu</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Nnu</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">alpha_nu</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">fc</span>
            <span class="o">/</span> <span class="n">fcb</span>
            <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">pc</span> <span class="o">+</span> <span class="n">pcb</span><span class="p">))</span>
            <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pcb</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.553</span> <span class="o">*</span> <span class="n">fnub</span> <span class="o">+</span> <span class="mf">0.126</span> <span class="o">*</span> <span class="n">fnub</span><span class="o">**</span><span class="mf">3.0</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.193</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fnu</span><span class="p">)</span> <span class="o">*</span> <span class="n">Nnu</span><span class="o">**</span><span class="mf">0.2</span> <span class="o">+</span> <span class="mf">0.169</span> <span class="o">*</span> <span class="n">fnu</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">yd</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">pcb</span> <span class="o">-</span> <span class="n">pc</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span>
                <span class="mi">1</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">pc</span> <span class="o">-</span> <span class="n">pcb</span><span class="p">)</span>
                <span class="o">/</span> <span class="mi">2</span>
                <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">7</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pcb</span><span class="p">))</span>
                <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">yd</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">eff_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.43</span> <span class="o">*</span> <span class="n">kvector</span> <span class="o">*</span> <span class="n">rs</span><span class="p">)</span> <span class="o">**</span> <span class="mf">4.0</span>
        <span class="p">)</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">kvector</span> <span class="o">/</span> <span class="p">(</span><span class="n">keq</span> <span class="o">/</span> <span class="mf">7.46e-2</span><span class="p">)</span> <span class="o">/</span> <span class="n">eff_shape</span>
        <span class="n">betac</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">0.949</span> <span class="o">*</span> <span class="n">fnub</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="c1"># transfer function is parametrized as:</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.84</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">)</span> <span class="o">*</span> <span class="n">betac</span> <span class="o">*</span> <span class="n">q0</span><span class="p">)</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="mf">14.4</span> <span class="o">+</span> <span class="mf">325.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">60.5</span> <span class="o">*</span> <span class="n">q0</span><span class="o">**</span><span class="mf">1.08</span><span class="p">)</span>
        <span class="n">T0</span> <span class="o">=</span> <span class="n">L0</span> <span class="o">/</span> <span class="p">(</span><span class="n">L0</span> <span class="o">+</span> <span class="n">C0</span> <span class="o">*</span> <span class="n">q0</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="c1"># growth function</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">5</span>
            <span class="o">*</span> <span class="n">Omm_at_z</span>
            <span class="o">/</span> <span class="mf">2.0</span>
            <span class="o">/</span> <span class="p">(</span>
                <span class="n">Omm_at_z</span> <span class="o">**</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">7.0</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">OmLambda_at_z</span>
                <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">Omm_at_z</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">OmLambda_at_z</span> <span class="o">/</span> <span class="mf">70.0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">fnu</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">yfs</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">qnu</span> <span class="o">=</span> <span class="mf">3.92</span> <span class="o">*</span> <span class="n">q0</span>
            <span class="n">Dcbnu</span> <span class="o">=</span> <span class="n">D1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yfs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">17.2</span>
                <span class="o">*</span> <span class="n">fnu</span>
                <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.488</span> <span class="o">*</span> <span class="n">fnu</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">7.0</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">))</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">Nnu</span> <span class="o">*</span> <span class="n">q0</span> <span class="o">/</span> <span class="n">fnu</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span>
            <span class="p">)</span>
            <span class="n">qnu</span> <span class="o">=</span> <span class="mf">3.92</span> <span class="o">*</span> <span class="n">q0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nnu</span> <span class="o">/</span> <span class="n">fnu</span><span class="p">)</span>
            <span class="n">Dcbnu</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcb</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.7</span> <span class="o">/</span> <span class="n">pcb</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">D1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">yfs</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.7</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span>
                <span class="n">pcb</span> <span class="o">/</span> <span class="mf">0.7</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">D1</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pcb</span><span class="p">)</span>

        <span class="n">Bk</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.24</span> <span class="o">*</span> <span class="n">fnu</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.64</span><span class="p">)</span> <span class="o">*</span> <span class="n">Nnu</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.3</span> <span class="o">+</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">fnu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">qnu</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.6</span><span class="p">)</span> <span class="o">+</span> <span class="n">qnu</span><span class="o">**</span><span class="mf">0.8</span>
        <span class="p">)</span>
        <span class="n">Tcbnu</span> <span class="o">=</span> <span class="n">T0</span> <span class="o">*</span> <span class="n">Dcbnu</span> <span class="o">/</span> <span class="n">D1</span> <span class="o">*</span> <span class="n">Bk</span>

        <span class="n">deltah</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.94e-5</span>
            <span class="o">*</span> <span class="n">Omm</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.785</span> <span class="o">-</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Omm</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.95</span> <span class="o">*</span> <span class="p">(</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.169</span> <span class="o">*</span> <span class="p">(</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">Pk</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">2</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mf">2.0</span>
            <span class="o">*</span> <span class="n">deltah</span><span class="o">**</span><span class="mf">2.0</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">kvector</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">Tcbnu</span><span class="o">**</span><span class="mf">2.0</span>
            <span class="o">*</span> <span class="n">growth</span><span class="o">**</span><span class="mf">2.0</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">cosmo</span><span class="o">.</span><span class="n">Hubble</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">h</span><span class="p">())</span> <span class="o">**</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">+</span> <span class="n">ns</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Pk</span></div>


<div class="viewcode-block" id="EHclass.EH98_fit">
<a class="viewcode-back" href="../index.html#ShapeFit.EHclass.EH98_fit">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">EH98_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kvector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pvec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a simplified parametric Eisenstein &amp; Hu power spectrum fit.</span>

<span class="sd">        This method uses a reduced set of parameters to reproduce the EH98</span>
<span class="sd">        transfer function shape without requiring full cosmological calculations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kvector : array_like: np.ndarray</span>
<span class="sd">            Wavenumber values in h/Mpc.</span>
<span class="sd">        pvec : array_like: np.ndarray</span>
<span class="sd">            Parameters of the power spectrum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pk : ndarray: np.ndarray</span>
<span class="sd">            Power spectrum P(k) in arbitrary units (depends on pvec[5]).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keq</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 7.61728119e-02,</span>
        <span class="n">alpha_nu</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">eff_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">pvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">kvector</span><span class="p">)</span> <span class="o">**</span> <span class="mf">4.0</span>
        <span class="p">)</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">kvector</span> <span class="o">/</span> <span class="p">(</span><span class="n">keq</span> <span class="o">/</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">eff_shape</span>  <span class="c1"># 7.61728119e-02/5.95675857e-01,</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">)</span> <span class="o">*</span> <span class="n">q0</span><span class="p">)</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="mf">14.4</span> <span class="o">+</span> <span class="mf">325.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">60.5</span> <span class="o">*</span> <span class="n">q0</span><span class="o">**</span><span class="mf">1.08</span><span class="p">)</span>
        <span class="n">T0</span> <span class="o">=</span> <span class="n">L0</span> <span class="o">/</span> <span class="p">(</span><span class="n">L0</span> <span class="o">+</span> <span class="n">C0</span> <span class="o">*</span> <span class="n">q0</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="n">Pk</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">kvector</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">pvec</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="n">T0</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">Pk</span></div>


<div class="viewcode-block" id="EHclass.EH98_fit_modified">
<a class="viewcode-back" href="../index.html#ShapeFit.EHclass.EH98_fit_modified">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">EH98_fit_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kvector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pvec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a modified parametric Eisenstein &amp; Hu power spectrum fit.</span>

<span class="sd">        Same as EH98_fit, but allows modification of the exponent in the</span>
<span class="sd">        small-scale suppression term of the transfer function, making it</span>
<span class="sd">        more flexible for non-standard cosmologies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kvector : array_like: np.ndarray</span>
<span class="sd">            Wavenumber values in h/Mpc.</span>
<span class="sd">        pvec : array_like: np.ndarray</span>
<span class="sd">            Parameters of the power spectrum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pk : np.ndarray</span>
<span class="sd">            Power spectrum P(k) in arbitrary units (depends on pvec[5]).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_nu</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">eff_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">pvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">kvector</span><span class="p">)</span> <span class="o">**</span> <span class="mf">4.0</span>
        <span class="p">)</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">kvector</span> <span class="o">/</span> <span class="p">(</span><span class="n">pvec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">eff_shape</span>  <span class="c1"># 7.61728119e-02/5.95675857e-01,</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_nu</span><span class="p">)</span> <span class="o">*</span> <span class="n">q0</span><span class="p">)</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="mf">14.4</span> <span class="o">+</span> <span class="mf">325.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">60.5</span> <span class="o">*</span> <span class="n">q0</span><span class="o">**</span><span class="mf">1.08</span><span class="p">)</span>
        <span class="n">T0</span> <span class="o">=</span> <span class="n">L0</span> <span class="o">/</span> <span class="p">(</span><span class="n">L0</span> <span class="o">+</span> <span class="n">C0</span> <span class="o">*</span> <span class="n">q0</span> <span class="o">**</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>
        <span class="n">Pk</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">kvector</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">pvec</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="n">T0</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># +pvec[7]*np.log(kvector)</span>
        <span class="k">return</span> <span class="n">Pk</span></div>
</div>



<div class="viewcode-block" id="slope_maker">
<a class="viewcode-back" href="../index.html#ShapeFit.slope_maker">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">slope_maker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains different ways of post processing the power spectrum,</span>
<span class="sd">    and different derivative methods to compute the slope.</span>

<span class="sd">    Methods in this class:</span>
<span class="sd">      - smooth_ratio: Smooth a the power spectra ratio as a function of wavenumbers, k using the selected method.</span>
<span class="sd">      - slope_at_x: Compute the slope (derivative) of the ratio using a variety of numerical and analytical methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="slope_maker.smooth_ratio">
<a class="viewcode-back" href="../index.html#ShapeFit.slope_maker.smooth_ratio">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth_ratio</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">xvector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">yvector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">smoothmethod</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth a the power spectra ratio as a function of wavenumbers, k using the selected method.</span>

<span class="sd">        Supported smoothing methods:</span>
<span class="sd">        - &quot;none&quot; : no smoothing, returns yvector unchanged</span>
<span class="sd">        - &quot;mean&quot; : Moving average smoothing over a fixed logarithmic window (~1.3 decades).</span>
<span class="sd">            Window size is determined relative to the log-scale extent of `xvector`.</span>
<span class="sd">            Boundary regions are handled with progressively smaller windows.</span>

<span class="sd">        - &quot;savitzky&quot; :</span>
<span class="sd">            Savitzky–Golay smoothing (polynomial least-squares fit in a moving window).</span>
<span class="sd">            Fits a polynomial of fixed order (default polyorder=3) over an odd-sized window.</span>

<span class="sd">        For the &quot;mean&quot; method:</span>
<span class="sd">        - Defines a smoothing window size based on a fixed `decade` scale (1.3 decades in log-space)</span>
<span class="sd">        - Applies an averaging filter with special handling for boundaries</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xvector : array_like: np.ndarray</span>
<span class="sd">            k-values in h/Mpc</span>
<span class="sd">        yvector : array_like: np.ndarray</span>
<span class="sd">            Power spectrum ratio</span>
<span class="sd">        smoothmethod : str, optional</span>
<span class="sd">            Smoothing method to apply. One of {&quot;none&quot;, &quot;mean&quot;, &quot;savitzky&quot;}.</span>
<span class="sd">            Default is &quot;none&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smoothed : ndarray: np.ndarray</span>
<span class="sd">            Smoothed power spectrum values, same shape as input.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If an unrecognized smoothing method name is provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">smoothmethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">yvector</span>
        <span class="k">elif</span> <span class="n">smoothmethod</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">decade</span> <span class="o">=</span> <span class="mf">1.3</span>
            <span class="n">delta_ln_k</span> <span class="o">=</span> <span class="n">decade</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>

            <span class="n">k_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span>
            <span class="n">k_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span>

            <span class="c1"># Determine window size for averaging and create an average</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">delta_ln_k</span> <span class="o">/</span> <span class="p">(</span><span class="n">k_max</span> <span class="o">-</span> <span class="n">k_min</span><span class="p">)))</span>
            <span class="n">avg_filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>

            <span class="c1"># Ensure the smoothing window is smaller than the data range</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">delta_ln_k</span> <span class="o">/</span> <span class="p">(</span><span class="n">k_max</span> <span class="o">-</span> <span class="n">k_min</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">1</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span>

            <span class="c1"># Calculate half of the window size for boundary handling</span>
            <span class="n">half_window</span> <span class="o">=</span> <span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Apply the averaging filter to the main part of the data</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">half_window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">+</span> <span class="n">half_window</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">yvector</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">half_window</span> <span class="p">:</span> <span class="n">i</span> <span class="o">-</span> <span class="n">half_window</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">]</span>
                        <span class="o">*</span> <span class="n">avg_filter</span>
                    <span class="p">)</span>
                    <span class="o">/</span> <span class="n">window_size</span>
                <span class="p">)</span>

            <span class="c1"># Handle the left boundary of the data</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">half_window</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">yvector</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span> <span class="n">avg_filter</span><span class="p">[:</span><span class="n">size</span><span class="p">])</span> <span class="o">/</span> <span class="n">size</span>

            <span class="c1"># Handle the right boundary of the data</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span> <span class="o">-</span> <span class="n">half_window</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">yvector</span><span class="p">[</span><span class="o">-</span><span class="n">size</span><span class="p">:]</span> <span class="o">*</span> <span class="n">avg_filter</span><span class="p">[</span><span class="o">-</span><span class="n">size</span><span class="p">:])</span> <span class="o">/</span> <span class="n">size</span>

            <span class="n">pk_mean</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">pk_mean</span>

        <span class="k">elif</span> <span class="n">smoothmethod</span> <span class="o">==</span> <span class="s2">&quot;savitzky&quot;</span><span class="p">:</span>
            <span class="n">decade</span> <span class="o">=</span> <span class="mf">2.5</span>
            <span class="n">delta_ln_k</span> <span class="o">=</span> <span class="n">decade</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
            <span class="n">k_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span>
            <span class="n">k_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span>

            <span class="c1"># Determine odd window size based on log-scale span</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">delta_ln_k</span> <span class="o">/</span> <span class="p">(</span><span class="n">k_max</span> <span class="o">-</span> <span class="n">k_min</span><span class="p">)))</span>

            <span class="c1"># Apply Savitzky–Golay filter (3rd-order polynomial)</span>
            <span class="n">pk_savgol</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">yvector</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pk_savgol</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unrecognized smoothing method </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smoothmethod</span><span class="p">))</span></div>


<div class="viewcode-block" id="slope_maker.slope_at_x">
<a class="viewcode-back" href="../index.html#ShapeFit.slope_maker.slope_at_x">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">slope_at_x</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xvector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">yvector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">derivmethod</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sam&quot;</span><span class="p">,</span>
        <span class="n">smoothmethod</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="n">inputinfo</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">return_approx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the slope (derivative) of y(x) using a variety of numerical and analytical methods.</span>

<span class="sd">        Optionally applies smoothing before computing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xvector : array_like: np.ndarray</span>
<span class="sd">            ln(k) or k values</span>
<span class="sd">        yvector : array_like: np.ndarray</span>
<span class="sd">            ln(P(k)) or P(k) values</span>
<span class="sd">        derivmethod : str, optional</span>
<span class="sd">            Method for computing the derivative. One of:</span>
<span class="sd">                &quot;sam&quot; :</span>
<span class="sd">                    Fit a cubic B-spline (k=5, s=3) to all data, take its derivative.</span>
<span class="sd">                &quot;sam_res&quot; :</span>
<span class="sd">                    Same as &quot;sam&quot;, but fit only within a restricted log(k) range from `inputinfo`.</span>
<span class="sd">                &quot;gradient&quot; :</span>
<span class="sd">                    Use NumPy&#39;s `np.gradient` to compute finite differences.</span>
<span class="sd">                &quot;poly&quot; :</span>
<span class="sd">                    Fit a polynomial (default deg=2) within log(k) range from `inputinfo`, then take its derivative.</span>
<span class="sd">                &quot;steps&quot; :</span>
<span class="sd">                    Compute slope between two given x-values in `inputinfo[&quot;xvals&quot;]` and return constant slope.</span>
<span class="sd">                &quot;tanh&quot; :</span>
<span class="sd">                    Fit an exponential-tanh function with fixed `a` and `kpiv` from `inputinfo`,</span>
<span class="sd">                    return derivative divided by function value.</span>
<span class="sd">                &quot;tanh_fit&quot; :</span>
<span class="sd">                    Similar to &quot;tanh&quot;, but `a` and `kpiv` are also fitted, within bounds.</span>

<span class="sd">        smoothmethod : str, optional</span>
<span class="sd">            Smoothing method to apply before derivative calculation.</span>
<span class="sd">            Passed to `self.smooth_ratio()` (e.g., &quot;none&quot;, &quot;mean&quot;, &quot;savitzky&quot;).</span>
<span class="sd">        inputinfo : dict, optional</span>
<span class="sd">            Additional parameters needed for some derivative methods:</span>
<span class="sd">                - kmin, kmax : bounds for restricted fits (&quot;sam_res&quot;, &quot;poly&quot;)</span>
<span class="sd">                - degree : polynomial degree for &quot;poly&quot;</span>
<span class="sd">                - xvals : [xlow, xhigh] for &quot;steps&quot;</span>
<span class="sd">                - a, kpiv : parameters for &quot;tanh&quot;</span>
<span class="sd">        return_approx : bool, optional</span>
<span class="sd">            If True, also return the smoothed/approximated y(x) used for the derivative.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diff : ndarray: np.ndarray</span>
<span class="sd">            Derivative dlnP(k)/dlnk.</span>
<span class="sd">        approx : ndarray, optional</span>
<span class="sd">            Only returned if `return_approx=True`. The approximated y(x) used for derivative.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If `derivmethod` is not recognized.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Apply smoothing if requested</span>
        <span class="n">yvector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_ratio</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="n">yvector</span><span class="p">,</span> <span class="n">smoothmethod</span><span class="o">=</span><span class="n">smoothmethod</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">derivmethod</span> <span class="o">==</span> <span class="s2">&quot;sam&quot;</span><span class="p">:</span>
            <span class="c1"># Create a B-spline representation of (xvector, yvector)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="n">yvector</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

            <span class="c1"># Evaluate the first derivative of the spline at all points in xvector</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Optionally compute the spline approximation of yvector</span>
            <span class="k">if</span> <span class="n">return_approx</span><span class="p">:</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">derivmethod</span> <span class="o">==</span> <span class="s2">&quot;sam_res&quot;</span><span class="p">:</span>
            <span class="c1"># Create a mask to select only x values within a specified log range</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">xvector</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kmin&quot;</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)),</span>
                <span class="n">xvector</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kmax&quot;</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">)),</span>
            <span class="p">)</span>

            <span class="c1"># Fit a quintic spline to only the masked data</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">xvector</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">yvector</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

            <span class="c1"># Evaluate first derivative of spline over entire xvector</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Optionally compute spline approximation of yvector</span>
            <span class="k">if</span> <span class="n">return_approx</span><span class="p">:</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">derivmethod</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="c1"># Use numpy&#39;s finite difference method to compute dy/dx</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">yvector</span><span class="p">,</span> <span class="n">xvector</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_approx</span><span class="p">:</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">yvector</span>

        <span class="k">elif</span> <span class="n">derivmethod</span> <span class="o">==</span> <span class="s2">&quot;poly&quot;</span><span class="p">:</span>
            <span class="c1"># Restrict data range using mask</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">xvector</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kmin&quot;</span><span class="p">,</span> <span class="mf">0.008</span><span class="p">)),</span>
                <span class="n">xvector</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kmin&quot;</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">)),</span>
            <span class="p">)</span>

            <span class="c1"># Fit polynomial of specified degree to masked data</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">Polynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="n">xvector</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">yvector</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">deg</span><span class="o">=</span><span class="n">inputinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;degree&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Compute first derivative of polynomial at all points</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">deriv</span><span class="p">()(</span><span class="n">xvector</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_approx</span><span class="p">:</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">derivmethod</span> <span class="o">==</span> <span class="s2">&quot;steps&quot;</span><span class="p">:</span>
            <span class="c1"># Get log of low and high x values from inputinfo</span>
            <span class="n">xlow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="p">[</span><span class="s2">&quot;xvals&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xhigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="p">[</span><span class="s2">&quot;xvals&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Find indices in xvector closest to xlow and xhigh</span>
            <span class="n">idxlow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">xvector</span> <span class="o">-</span> <span class="n">xlow</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">idxhigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">xvector</span> <span class="o">-</span> <span class="n">xhigh</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Get corresponding y values</span>
            <span class="n">pklow</span> <span class="o">=</span> <span class="n">yvector</span><span class="p">[</span><span class="n">idxlow</span><span class="p">]</span>
            <span class="n">pkhigh</span> <span class="o">=</span> <span class="n">yvector</span><span class="p">[</span><span class="n">idxhigh</span><span class="p">]</span>

            <span class="c1"># Compute slope between these two points</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">pkhigh</span> <span class="o">-</span> <span class="n">pklow</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xhigh</span> <span class="o">-</span> <span class="n">xlow</span><span class="p">)</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">xvector</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_approx</span><span class="p">:</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">xvector</span> <span class="o">-</span> <span class="n">xhigh</span><span class="p">)</span> <span class="o">+</span> <span class="n">pkhigh</span>

        <span class="k">elif</span> <span class="n">derivmethod</span> <span class="o">==</span> <span class="s2">&quot;tanh&quot;</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span>
                <span class="n">lnk</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">deltans</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">inputinfo</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">],</span> <span class="n">lnkpiv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="p">[</span><span class="s2">&quot;kpiv&quot;</span><span class="p">])</span>
            <span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Fitting the power spectrum</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="n">d</span> <span class="o">+</span> <span class="n">deltans</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dfunc_dlnk</span><span class="p">(</span>
                <span class="n">lnk</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">deltans</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">inputinfo</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">],</span> <span class="n">lnkpiv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inputinfo</span><span class="p">[</span><span class="s2">&quot;kpiv&quot;</span><span class="p">])</span>
            <span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Compute the derivative of the model with respect to lnk</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="n">d</span> <span class="o">+</span> <span class="n">deltans</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">))</span>
                <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">deltans</span><span class="p">)</span>

            <span class="c1"># Mask: fit only within certain log(k) range</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">xvector</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">),</span> <span class="n">xvector</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

            <span class="c1"># Fit parameters of func to masked data (yvector is exponentiated)</span>
            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">xvector</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">yvector</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span> <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.011</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Compute derivative</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">dfunc_dlnk</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span> <span class="o">/</span> <span class="n">func</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_approx</span><span class="p">:</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">derivmethod</span> <span class="o">==</span> <span class="s2">&quot;tanh_fit&quot;</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">lnk</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">deltans</span><span class="p">,</span> <span class="n">lnkpiv</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Fitting the power spectrum</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="n">d</span> <span class="o">+</span> <span class="n">deltans</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dfunc_dlnk</span><span class="p">(</span><span class="n">lnk</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">deltans</span><span class="p">,</span> <span class="n">lnkpiv</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Compute the derivative of the model with respect to lnk</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="n">d</span> <span class="o">+</span> <span class="n">deltans</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">))</span>
                <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">-</span> <span class="n">lnkpiv</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">deltans</span><span class="p">)</span>

            <span class="c1"># Mask range</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">xvector</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">),</span> <span class="n">xvector</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

            <span class="c1"># Fit with bounds on parameters</span>
            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span>
                <span class="n">xvector</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">yvector</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span>
                <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.011</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)],</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">(</span>
                    <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)],</span>
                    <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)],</span>
                <span class="p">),</span>
            <span class="p">)</span>

            <span class="c1"># Compute relative slope</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">dfunc_dlnk</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span> <span class="o">/</span> <span class="n">func</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_approx</span><span class="p">:</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">xvector</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No such </span><span class="si">{</span><span class="n">derivmethod</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_approx</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">diff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">diff</span><span class="p">,</span> <span class="n">approx</span></div>
</div>



<div class="viewcode-block" id="smoother">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">smoother</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains different smoothing algorithms for the power spectrum.</span>
<span class="sd">    The existing algorithms:</span>
<span class="sd">      - Numerical smoothing:</span>
<span class="sd">          -- smoothing_method_1509_1: Gaussian smoothing</span>
<span class="sd">      - Fitting smooth functions:</span>
<span class="sd">          -- smoothing_method_1604: Polynomial fit</span>
<span class="sd">          -- smoothing_method_1605_3 : Cubic Spline fit</span>
<span class="sd">          -- smoothing_method_1509_2 : B-Spline fit</span>
<span class="sd">          -- smoothing_method_1509_3 : Multiple B-Spline fit</span>
<span class="sd">          -- smoothing_method_univariate : Univariate Spline fit</span>
<span class="sd">          -- smoothing_method_1605_1 : EH fit</span>
<span class="sd">          -- smoothing_method_1605_2 : EH fit; second version</span>
<span class="sd">          -- smoothing_method_0907 : Cubic Spline fit</span>
<span class="sd">      - Inflections:</span>
<span class="sd">          -- MP, MP_v2 : Cubic inflections</span>
<span class="sd">      - Correlation function peak removal:</span>
<span class="sd">          -- smoothing_method_1301 : Hanckel transform</span>
<span class="sd">          -- smoothing_method_2004 : Fast sine transform</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="smoother.MP">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.MP">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">MP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">k_ref</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0022</span><span class="p">,</span> <span class="mf">4.5e-1</span><span class="p">]),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXive paper 1210.7183, 1804.07261.</span>

<span class="sd">        Function computing the analytical solution for smoothing the power spectrum</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ----------</span>
<span class="sd">        k_in: np.ndarray:</span>
<span class="sd">            set of wave numbers corresponding to the values of our power spectrum</span>
<span class="sd">        pk_in: np.ndarray:</span>
<span class="sd">            input power spectrum to be smoothed</span>
<span class="sd">        k_ref : np.ndarray:</span>
<span class="sd">            wave numbers corresponding to the BAO features</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smoothed : np.ndarray:</span>
<span class="sd">            smoothed power spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Minimum and maximum wave numbers that contain the BAO features</span>
        <span class="n">k_ref_min</span> <span class="o">=</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">k_ref_max</span> <span class="o">=</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># 1) Fit the power spectrum without BAO features using a univariate Spline</span>
        <span class="c1"># Spline all (log-log) points outside k_ref range:</span>
        <span class="n">no_bao_features_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&lt;=</span> <span class="n">k_ref_min</span><span class="p">,</span> <span class="n">k_in</span> <span class="o">&gt;=</span> <span class="n">k_ref_max</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Smoothing spline fit to a given set of data points</span>
        <span class="n">fun_pk_smooth</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k_in</span><span class="p">[</span><span class="n">no_bao_features_idxs</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pk_in</span><span class="p">[</span><span class="n">no_bao_features_idxs</span><span class="p">]),</span>
            <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lambda_pk_smooth</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">fun_pk_smooth</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">pk_smoothed</span> <span class="o">=</span> <span class="n">lambda_pk_smooth</span><span class="p">(</span><span class="n">k_in</span><span class="p">)</span>

        <span class="c1"># 2) Get a spline fitting the ratio between the input power spectrum and the smoothed one</span>
        <span class="c1">#    find its second derivative, and from it recover maxima and minima of the wiggles</span>

        <span class="c1"># UnivariateSpline is used to fit a spline pk_in=spl(k_in) of degree k to the provided k_in and pk_in/pk_smooth data</span>
        <span class="n">fun_spline_wiggles</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">k_in</span><span class="p">,</span> <span class="n">pk_in</span> <span class="o">/</span> <span class="n">pk_smoothed</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Find all derivatives of the spline</span>
        <span class="n">derivs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fun_spline_wiggles</span><span class="o">.</span><span class="n">derivatives</span><span class="p">(</span><span class="n">_k</span><span class="p">)</span> <span class="k">for</span> <span class="n">_k</span> <span class="ow">in</span> <span class="n">k_in</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Fit a spline on the second derivative of the wiggles</span>
        <span class="n">deriv_2</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">k_in</span><span class="p">,</span> <span class="n">derivs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Find maxima and minima of the gradient (zeros of 2nd deriv.), then put a</span>
        <span class="c1"># low-order spline through zeros to subtract smooth trend from wiggles fn.</span>
        <span class="n">wiggle_zeros</span> <span class="o">=</span> <span class="n">deriv_2</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>

        <span class="c1"># Remove the zeros outside the range of interest (k&lt;k_ref_min or k&gt;k_ref_max)</span>
        <span class="n">wiggle_zeros</span> <span class="o">=</span> <span class="n">wiggle_zeros</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">wiggle_zeros</span> <span class="o">&gt;=</span> <span class="n">k_ref_min</span><span class="p">,</span> <span class="n">wiggle_zeros</span> <span class="o">&lt;=</span> <span class="n">k_ref_max</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Remove the first zero in the defined k range(k_ref_min,k_ref_max)</span>
        <span class="n">wiggle_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">wiggle_zeros</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># 3) Fit a spline through the maxima and minima of the fitted spline</span>
        <span class="c1"># Find the index of the maximum of the power spectrum to have the peak as a point for the interpolation</span>
        <span class="n">k_pk_max</span> <span class="o">=</span> <span class="n">k_in</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pk_in</span><span class="p">)]</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&gt;</span> <span class="n">k_ref_max</span><span class="p">)</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">right_side</span><span class="p">)</span>
        <span class="n">left_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&lt;</span> <span class="n">k_pk_max</span><span class="p">)</span>  <span class="c1"># *0.6)</span>
        <span class="n">left_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">left_side</span><span class="p">)</span>

        <span class="n">k_fin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_in</span><span class="p">[</span><span class="n">left_side</span><span class="p">],</span> <span class="n">wiggle_zeros</span><span class="p">,</span> <span class="n">k_in</span><span class="p">[</span><span class="n">right_side</span><span class="p">]))</span>

        <span class="n">wiggle_spline_trend</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span>
            <span class="n">k_fin</span><span class="p">,</span> <span class="n">fun_spline_wiggles</span><span class="p">(</span><span class="n">k_fin</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="c1"># 4) Put together the results of step 1, 2 and 3</span>
        <span class="c1"># Construct smooth no-BAO:</span>
        <span class="n">bao_features_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&gt;</span> <span class="n">k_ref_min</span><span class="p">,</span> <span class="n">k_in</span> <span class="o">&lt;</span> <span class="n">k_ref_max</span><span class="p">))</span>
        <span class="n">wave_numbers_bao_features</span> <span class="o">=</span> <span class="n">k_in</span><span class="p">[</span><span class="n">bao_features_idxs</span><span class="p">]</span>

        <span class="c1"># Update the smoothed values given the wiggle spline trend</span>
        <span class="n">pk_smoothed</span><span class="p">[</span><span class="n">bao_features_idxs</span><span class="p">]</span> <span class="o">*=</span> <span class="n">wiggle_spline_trend</span><span class="p">(</span><span class="n">wave_numbers_bao_features</span><span class="p">)</span>

        <span class="c1"># Interpolate to get the final smoothed power spectrum</span>
        <span class="n">ipk</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
            <span class="n">k_in</span><span class="p">,</span> <span class="n">pk_smoothed</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="p">)</span>
        <span class="n">pk_smoothed</span> <span class="o">=</span> <span class="n">ipk</span><span class="p">(</span><span class="n">k_in</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smoothed</span></div>


<div class="viewcode-block" id="smoother.MP_v2">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.MP_v2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">MP_v2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">k_ref</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">[</span><span class="mf">8e-3</span><span class="p">,</span> <span class="mf">4e-1</span><span class="p">],</span>
        <span class="n">factor_left</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXive paper 1210.7183, 1804.07261</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ----------</span>
<span class="sd">        k_in: np.ndarray:</span>
<span class="sd">            set of wave numbers corresponding to the values of our power spectrum</span>
<span class="sd">        pk_in: np.ndarray:</span>
<span class="sd">            input power spectrum to be smoothed</span>
<span class="sd">        k_ref : np.ndarray:</span>
<span class="sd">            wave numbers corresponding to the BAO features</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_nobao : np.ndarray:</span>
<span class="sd">            smoothed power spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Spline all (log-log) points outside k_ref range:</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&lt;=</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_in</span> <span class="o">&gt;=</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">_pk_smooth</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k_in</span><span class="p">[</span><span class="n">idxs</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pk_in</span><span class="p">[</span><span class="n">idxs</span><span class="p">]),</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_pk_smooth</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

        <span class="c1"># Find second derivative of each spline:</span>
        <span class="n">fwiggle</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">k_in</span><span class="p">,</span> <span class="n">pk_in</span> <span class="o">/</span> <span class="n">pk_smooth</span><span class="p">(</span><span class="n">k_in</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">derivs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fwiggle</span><span class="o">.</span><span class="n">derivatives</span><span class="p">(</span><span class="n">_k</span><span class="p">)</span> <span class="k">for</span> <span class="n">_k</span> <span class="ow">in</span> <span class="n">k_in</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">k_in</span><span class="p">,</span> <span class="n">derivs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Find maxima and minima of the gradient (zeros of 2nd deriv.), then put a</span>
        <span class="c1"># low-order spline through zeros to subtract smooth trend from wiggles fn.</span>
        <span class="n">wzeros</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">PPoly</span><span class="o">.</span><span class="n">from_spline</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">extrapolate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Remove the zeros outside the range of interest (k&lt;k_ref_min or k&gt;k_ref_max)</span>
        <span class="n">wzeros</span> <span class="o">=</span> <span class="n">wzeros</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">wzeros</span> <span class="o">&gt;=</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wzeros</span> <span class="o">&lt;=</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="p">]</span>
        <span class="n">wzeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">wzeros</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># find the index of the maximum of the power spectrum to have the peak as a point for the interpolation</span>
        <span class="n">k_pk_max</span> <span class="o">=</span> <span class="n">k_in</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pk_in</span><span class="p">)]</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&gt;</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">right_side</span><span class="p">)</span>
        <span class="n">left_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&lt;</span> <span class="n">k_pk_max</span> <span class="o">*</span> <span class="n">factor_left</span><span class="p">)</span>
        <span class="n">left_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">left_side</span><span class="p">)</span>

        <span class="n">k_fin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_in</span><span class="p">[</span><span class="n">left_side</span><span class="p">],</span> <span class="n">wzeros</span><span class="p">,</span> <span class="n">k_in</span><span class="p">[</span><span class="n">right_side</span><span class="p">]))</span>

        <span class="n">wtrend</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">k_fin</span><span class="p">,</span> <span class="n">fwiggle</span><span class="p">(</span><span class="n">k_fin</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Construct smooth no-BAO:</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">k_in</span> <span class="o">&gt;</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">factor_left</span><span class="p">,</span> <span class="n">k_in</span> <span class="o">&lt;</span> <span class="n">k_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">pk_nobao</span> <span class="o">=</span> <span class="n">pk_smooth</span><span class="p">(</span><span class="n">k_in</span><span class="p">)</span>
        <span class="n">pk_nobao</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">*=</span> <span class="n">wtrend</span><span class="p">(</span><span class="n">k_in</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span>

        <span class="c1"># Construct interpolating functions:</span>
        <span class="n">ipk</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
            <span class="n">k_in</span><span class="p">,</span> <span class="n">pk_nobao</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="p">)</span>

        <span class="n">pk_nobao</span> <span class="o">=</span> <span class="n">ipk</span><span class="p">(</span><span class="n">k_in</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pk_nobao</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1301">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1301">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1301</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">krepstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">krepwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">rfitlow</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">rlow</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">86</span><span class="p">,</span>
        <span class="n">rhigh</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span>
        <span class="n">rfithigh</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">190</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXiv paper 1301.3456</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ----------</span>
<span class="sd">        ks: np.ndarray:</span>
<span class="sd">            set of wave numbers, k corresponding to the values of our power spectrum.</span>
<span class="sd">        pks: np.ndarray:</span>
<span class="sd">            input power spectrum P(k) to be smoothed.</span>
<span class="sd">        k_repstart : float</span>
<span class="sd">            wavenumber where the replacement function starts to take effect.</span>
<span class="sd">        krepwidth : float</span>
<span class="sd">            transition width (in log-space) for smoothly blending smoothed and original spectra.</span>
<span class="sd">        rfitlow : float</span>
<span class="sd">            lower bound in configuration space for the fit region.</span>
<span class="sd">        rlow : float</span>
<span class="sd">            lower bound for the range of r where the correlation function will be replaced.</span>
<span class="sd">        rhigh : float</span>
<span class="sd">            upper bound for the range of r where the correlation function will be replaced.</span>
<span class="sd">        rfithigh : float</span>
<span class="sd">            upper bound in configuration space for the fit region.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smooth_pk : np.ndarray:</span>
<span class="sd">            smoothed no-wiggle power spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fitfunc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">pars</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Polynomial-like fitting function</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="n">pars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pars</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span> <span class="o">+</span> <span class="n">pars</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pars</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="o">**</span><span class="mi">3</span>

        <span class="c1"># 1) Transform P(k) → ξ(r) using the Fourier–Hankel transform</span>
        <span class="n">xi_v</span> <span class="o">=</span> <span class="n">fht</span><span class="p">(</span>
            <span class="n">pks</span> <span class="o">*</span> <span class="p">(</span><span class="n">ks</span><span class="o">**</span><span class="mf">1.5</span><span class="p">),</span> <span class="n">dln</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">))[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias</span><span class="o">=-</span><span class="mf">0.8</span>
        <span class="p">)</span>

        <span class="c1"># Generate r-space array (distances corresponding to k-values)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ks</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Normalize ξ(r) from the transformed ξ_v</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi_v</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="mf">1.5</span>

        <span class="c1"># 2) Identify fitting region in r-space</span>
        <span class="c1"># rmask selects points in the fitting range [rfitlow, rlow] U [rhigh, rfithigh]</span>
        <span class="n">rmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">rfitlow</span><span class="p">,</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rlow</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">rhigh</span><span class="p">,</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rfithigh</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">xi_fit</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="n">rmask</span><span class="p">]</span>  <span class="c1"># Values to fit</span>
        <span class="n">r_fit</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">rmask</span><span class="p">]</span>  <span class="c1"># Corresponding r-values</span>

        <span class="c1"># 3) Fit correlation function in selected region</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">fitfunc</span><span class="p">,</span> <span class="n">r_fit</span><span class="p">,</span> <span class="n">xi_fit</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># 4) Replace ξ(r) in the target range (rlow, rhigt)</span>
        <span class="n">rmask_replace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">rlow</span><span class="p">,</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rhigh</span><span class="p">)</span>
        <span class="n">replace_xi</span> <span class="o">=</span> <span class="n">fitfunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">rmask_replace</span><span class="p">],</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="n">xi</span><span class="p">[</span><span class="n">rmask_replace</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_xi</span>

        <span class="c1"># 5) Transform ξ(r) → smoothed P(k) using inverse Hankel transform</span>
        <span class="n">smooth_pk</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ifht</span><span class="p">(</span>
                <span class="n">xi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="mf">1.5</span><span class="p">,</span>
                <span class="n">dln</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">))[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">mu</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">bias</span><span class="o">=-</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">/</span> <span class="n">ks</span><span class="o">**</span><span class="mf">1.5</span>
        <span class="p">)</span>

        <span class="c1"># Ensure no extremely small or negative values</span>
        <span class="n">smooth_pk</span><span class="p">[</span><span class="n">smooth_pk</span> <span class="o">&lt;</span> <span class="mf">1e-20</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-20</span>

        <span class="c1"># 6) Blend smoothed and original spectrum for small k-values</span>
        <span class="c1"># Activation function controls transition in log(k)</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">krepstart</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>

        <span class="c1"># Smooth further using a spline in log-log space</span>
        <span class="n">smooth_pk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">smooth_pk</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># Combine original and smoothed P(k) with activation weighting</span>
        <span class="n">smooth_pk</span> <span class="o">=</span> <span class="n">pks</span><span class="o">**</span><span class="n">activation</span> <span class="o">*</span> <span class="n">smooth_pk</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">activation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smooth_pk</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_univariate">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_univariate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_univariate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">krepstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">krepend</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">krepwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">kfitlow</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">kfithigh</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">w_suppression</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooths a power spectrum using a Univariate Spline approach.</span>

<span class="sd">        The method fits a spline to the log-log representation of the power spectrum,</span>
<span class="sd">        optionally reducing the spline&#39;s weight in a specific k-range to</span>
<span class="sd">        avoid overfitting oscillatory features. The result is smoothly blended with</span>
<span class="sd">        the original spectrum in selected k-ranges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ks : np.ndarray</span>
<span class="sd">            Array of wavenumbers (1/Mpc) corresponding to the power spectrum values.</span>
<span class="sd">        pks : np.ndarray</span>
<span class="sd">            Power spectrum values P(k) to be smoothed.</span>
<span class="sd">        s : float</span>
<span class="sd">            Smoothing factor for the Univariate Spline. Smaller values fit more closely.</span>
<span class="sd">        krepstart : float</span>
<span class="sd">            Wavenumber where blending from original to smoothed spectrum begins.</span>
<span class="sd">        krepend : float</span>
<span class="sd">            Wavenumber where blending back to original ends.</span>
<span class="sd">        krepwidth : float</span>
<span class="sd">            Width (in log-space) of the blending transition.</span>
<span class="sd">        kfitlow : float</span>
<span class="sd">            Lower bound of k-range where spline fit weights are suppressed.</span>
<span class="sd">        kfithigh : float</span>
<span class="sd">            Upper bound of k-range where spline fit weights are suppressed.</span>
<span class="sd">        w_suppression : float</span>
<span class="sd">            Multiplicative factor for weight suppression in the fit range.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth: np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Create spline fit weights</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>
        <span class="c1"># Reduce weight for k-values in [kfitlow, kfithigh] to suppress BAO wiggles</span>
        <span class="n">wts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ks</span> <span class="o">&gt;</span> <span class="n">kfitlow</span><span class="p">,</span> <span class="n">ks</span> <span class="o">&lt;</span> <span class="n">kfithigh</span><span class="p">)]</span> <span class="o">*=</span> <span class="n">w_suppression</span>

        <span class="c1"># 2) Fit a spline to log-log data</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pks</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">wts</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># 3) Compute blending activation function</span>
        <span class="c1"># Transition from original (P(k)) to smoothed and back</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">krepstart</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">krepend</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># 4) Blend smoothed and original spectra</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pks</span><span class="o">**</span><span class="n">activation</span> <span class="o">*</span> <span class="n">pk_smooth</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">activation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1509_1">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1509_1">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1509_1</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">logkh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk_red</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kstart</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kend</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">krepstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">krepend</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">krepwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">lambdav</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXiv paper 1509.02120</span>

<span class="sd">        Smooths a reduced power spectrum using 1D Gaussian filtering in log(k) space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        logkh : np.ndarray</span>
<span class="sd">            Array of log(wavenumbers) corresponding to the power spectrum values.</span>
<span class="sd">        pk_red : np.ndarray</span>
<span class="sd">            Reduced power spectrum values P(k) to be smoothed.</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Array of wavenumbers (1/Mpc) corresponding to the power spectrum values.</span>
<span class="sd">        kstart : float</span>
<span class="sd">            Lower bound of wavenumber range to smooth.</span>
<span class="sd">        kend : float</span>
<span class="sd">            Upper bound of wavenumber range to smooth.</span>
<span class="sd">        krepstart : float</span>
<span class="sd">            Wavenumber where blending from original to smoothed spectrum begins.</span>
<span class="sd">        krepend : float</span>
<span class="sd">            Wavenumber where blending back to original ends.</span>
<span class="sd">        krepwidth : float</span>
<span class="sd">            Width (in log-space) of the blending transition.</span>
<span class="sd">        lambdav : float</span>
<span class="sd">            Width of the Gaussian filter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth: np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Copy input spectrum to avoid modifying the original</span>
        <span class="n">pnw</span> <span class="o">=</span> <span class="n">pk_red</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Apply Gaussian smoothing in log(k) space</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kh</span><span class="p">):</span>  <span class="c1"># enumerate returns both the indexes and the values</span>
            <span class="c1"># Filter the values of logkh only if the value of logkh is between</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">logkh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">logkh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">lambdav</span>
                <span class="ow">and</span> <span class="n">logkh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">logkh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">lambdav</span>
            <span class="p">):</span>
                <span class="c1"># Gaussian kernel in log(k) space</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">logkh</span> <span class="o">-</span> <span class="n">logkh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">lambdav</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># Integrate weighted spectrum using Simpson&#39;s rule</span>
                <span class="n">pnw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpson</span><span class="p">(</span><span class="n">pk_red</span> <span class="o">*</span> <span class="n">weights</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">logkh</span><span class="p">)</span>
                <span class="c1"># Normalize by Gaussian kernel area</span>
                <span class="n">pnw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">lambdav</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pnw</span>

        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1509_2">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1509_2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1509_2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">logkh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk_red</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kstart</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kend</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">krepwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXiv paper 1509.02120</span>

<span class="sd">        Smooths a reduced power spectrum using a B-spline fitting method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        logkh : np.ndarray</span>
<span class="sd">            Logarithmic values of wavenumber.</span>
<span class="sd">        pk_red : np.ndarray</span>
<span class="sd">            Power spectrum values.</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Linear k*h values corresponding to `logkh`.</span>
<span class="sd">        kstart : float</span>
<span class="sd">            Lower bound of k-range to fit and smooth.</span>
<span class="sd">        kend : float</span>
<span class="sd">            Upper bound of k-range to fit and smooth.</span>
<span class="sd">        krepwidth : float</span>
<span class="sd">            Width (in log-space) of the blending transition between smoothed and original.</span>
<span class="sd">        degree : int</span>
<span class="sd">            Degree of the B-spline used for fitting.</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of knots for the B-spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth: np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">minfun</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Computes sum of squared errors between the CubicSpline</span>
<span class="sd">            and a B-spline with the given coefficients over the fit range.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pk_red_t</span> <span class="o">-</span> <span class="n">BSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">degree</span><span class="p">)(</span><span class="n">t_dense</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mse</span>

        <span class="c1"># Copy spectrum to avoid modifying the input</span>
        <span class="n">pnw</span> <span class="o">=</span> <span class="n">pk_red</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Knot positions in log(k) space for B-spline fitting</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="n">kstart</span><span class="p">,</span> <span class="n">kh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># Mask for the fit region</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">kh</span> <span class="o">&gt;</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">kh</span> <span class="o">&lt;</span> <span class="n">kend</span><span class="p">)</span>
        <span class="n">t_dense</span> <span class="o">=</span> <span class="n">logkh</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># 1) Fit a cubic spline to the data</span>
        <span class="n">pk_red_t</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">logkh</span><span class="p">,</span> <span class="n">pk_red</span><span class="p">)(</span><span class="n">t_dense</span><span class="p">)</span>

        <span class="c1"># 2) Get initial B-spline coefficients from fit range</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">pk_red_t</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>

        <span class="c1"># 3) Optimize B-spline coefficients to minimize error vs. CubicSpline</span>
        <span class="n">optimization_result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">minfun</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># 4) Adjust transition region at the lower edge of the fit</span>
        <span class="n">firstidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">kh</span> <span class="o">&gt;</span> <span class="n">kstart</span><span class="p">)</span>
        <span class="n">staridx</span> <span class="o">=</span> <span class="n">firstidx</span> <span class="o">-</span> <span class="mi">50</span>

        <span class="c1"># Difference between B-spline and original at transition points</span>
        <span class="n">dpnw</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">BSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">optimization_result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">degree</span><span class="p">)(</span><span class="n">logkh</span><span class="p">[</span><span class="n">firstidx</span><span class="p">])</span> <span class="o">-</span> <span class="n">pnw</span><span class="p">[</span><span class="n">firstidx</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">dpnwp1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">BSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">optimization_result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">degree</span><span class="p">)(</span><span class="n">logkh</span><span class="p">[</span><span class="n">firstidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="o">-</span> <span class="n">pnw</span><span class="p">[</span><span class="n">firstidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Derivative estimate for transition matching</span>
        <span class="n">y1p</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">dpnwp1</span> <span class="o">-</span> <span class="n">dpnw</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">kh</span><span class="p">[</span><span class="n">firstidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kh</span><span class="p">[</span><span class="n">firstidx</span><span class="p">])</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">kh</span><span class="p">[</span><span class="n">firstidx</span><span class="p">]</span> <span class="o">-</span> <span class="n">kh</span><span class="p">[</span><span class="n">staridx</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">dpnw</span>

        <span class="c1"># Coefficients for cubic polynomial interpolation in transition</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">y1p</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y1</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y1p</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">kh</span><span class="p">[</span><span class="n">staridx</span><span class="p">:</span><span class="n">firstidx</span><span class="p">]</span> <span class="o">-</span> <span class="n">kh</span><span class="p">[</span><span class="n">staridx</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">kh</span><span class="p">[</span><span class="n">firstidx</span><span class="p">]</span> <span class="o">-</span> <span class="n">kh</span><span class="p">[</span><span class="n">staridx</span><span class="p">])</span>

        <span class="c1"># Apply cubic interpolation correction</span>
        <span class="n">pnw</span><span class="p">[</span><span class="n">staridx</span><span class="p">:</span><span class="n">firstidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnw</span><span class="p">[</span><span class="n">staridx</span><span class="p">:</span><span class="n">firstidx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

        <span class="c1"># Replace values in fit region with B-spline fit</span>
        <span class="n">pnw</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">BSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">optimization_result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">degree</span><span class="p">)(</span><span class="n">t_dense</span><span class="p">)</span>

        <span class="c1"># 5) Blend original and smoothed spectrum with activation function</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">logkh</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kend</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">krepwidth</span><span class="p">)</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
            <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">logkh</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kstart</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pk_red</span> <span class="o">*</span> <span class="n">activation</span> <span class="o">+</span> <span class="n">pnw</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">activation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1509_3">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1509_3">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1509_3</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">logkh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk_red</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kstart</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kend</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">krepwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXiv paper 1509.02120</span>

<span class="sd">        Smooths a reduced power spectrum by averaging multiple B-spline fits</span>
<span class="sd">        with different degrees and knot counts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        logkh : np.ndarray</span>
<span class="sd">            Logarithmic values of wavenumber k.</span>
<span class="sd">        pk_red : np.ndarray</span>
<span class="sd">            Power spectrum values.</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Linear k values corresponding to `logkh`.</span>
<span class="sd">        kstart : float</span>
<span class="sd">            Lower bound of k-range for smoothing.</span>
<span class="sd">        kend : float</span>
<span class="sd">            Upper bound of k-range for smoothing.</span>
<span class="sd">        krepwidth : float, optional</span>
<span class="sd">            Width (in log-space) of the transition between smoothed and original spectra.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth: np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">minfun</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Computes sum of squared errors between the CubicSpline</span>
<span class="sd">            and a B-spline with given coefficients in the fit range.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pk_red_t</span> <span class="o">-</span> <span class="n">BSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="s2">&quot;degree&quot;</span><span class="p">])(</span><span class="n">t_dense</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mse</span>

        <span class="n">pnw</span> <span class="o">=</span> <span class="n">pk_red</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Possible B-spline configurations to test</span>
        <span class="n">possibilities</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">14</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">14</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">16</span><span class="p">},</span>
        <span class="p">]</span>

        <span class="c1"># Mask for fit range in k-space</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">kh</span> <span class="o">&gt;</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">kh</span> <span class="o">&lt;</span> <span class="n">kend</span><span class="p">)</span>
        <span class="n">t_dense</span> <span class="o">=</span> <span class="n">logkh</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="n">nowiggles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">possibilities</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)))</span>
        <span class="c1"># 1) Fit CubicSpline to data in the fit range</span>
        <span class="n">pk_red_t</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">logkh</span><span class="p">,</span> <span class="n">pk_red</span><span class="p">)(</span><span class="n">t_dense</span><span class="p">)</span>

        <span class="c1"># 2) Fit multiple B-splines with different settings</span>
        <span class="k">for</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">possibilities</span><span class="p">):</span>
            <span class="n">deg</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="s2">&quot;degree&quot;</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="n">kstart</span><span class="p">,</span> <span class="n">kh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]))</span>

            <span class="c1"># Initial guess for B-spline coefficients</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">pk_red_t</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">deg</span><span class="p">)</span>

            <span class="c1"># Optimize coefficients to best match the CubicSpline</span>
            <span class="n">optimization_result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">minfun</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

            <span class="c1"># Store smoothed values for this configuration</span>
            <span class="n">nowiggles</span><span class="p">[</span><span class="n">ipos</span><span class="p">]</span> <span class="o">=</span> <span class="n">BSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">optimization_result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">deg</span><span class="p">)(</span><span class="n">t_dense</span><span class="p">)</span>

        <span class="c1"># 4) Average all &quot;no-wiggle&quot; fits</span>
        <span class="n">nowiggle_tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nowiggles</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pnw</span> <span class="o">=</span> <span class="n">pk_red</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Replace original spectrum values in mask range with averaged no-wiggle values</span>
        <span class="n">pnw</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">nowiggle_tot</span>

        <span class="c1"># 5) Blend original and smoothed spectra with activation function</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">logkh</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kend</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
            <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">logkh</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kstart</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pk_red</span> <span class="o">*</span> <span class="n">activation</span> <span class="o">+</span> <span class="n">pnw</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">activation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1604">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1604">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1604</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk_red</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sigmasq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">sigmasq_2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5e-3</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXiv paper 1604.01830</span>

<span class="sd">        Smooths a reduced power spectrum using a weighted polynomial fit in log(k) space</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Array of wavenumber k values.</span>
<span class="sd">        pk_red : np.ndarray</span>
<span class="sd">            Power spectrum values.</span>
<span class="sd">        sigmasq : float</span>
<span class="sd">            Variance of the first Gaussian weight suppression term.</span>
<span class="sd">        sigmasq_2 : float</span>
<span class="sd">            Variance of the second Gaussian weight adjustment term.</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Amplitude of the first Gaussian suppression term.</span>
<span class="sd">        beta : float</span>
<span class="sd">            Amplitude of the second Gaussian adjustment term.</span>
<span class="sd">        n : int</span>
<span class="sd">            Degree of the polynomial fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth: np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1) Convert k to log-space</span>
        <span class="n">logkh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span>

        <span class="c1"># 2) Define polynomial fit with weighted suppression</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.0</span>
            <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">kh</span> <span class="o">*</span> <span class="n">kh</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigmasq</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">kh</span> <span class="o">*</span> <span class="n">kh</span> <span class="o">/</span> <span class="n">sigmasq_2</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># 3) Fit polynomial in log(k) space</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">Polynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">logkh</span><span class="p">,</span> <span class="n">pk_red</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="c1"># 4) Evaluate polynomial to get smoothed P(k)</span>
        <span class="n">pnw</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">logkh</span><span class="p">)</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pnw</span>
        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1605_1">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1605_1">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1605_1</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">logkh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk_red</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kstart</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kend</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">krepstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">krepend</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">krepwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First smoothing method based on ArXiv paper 1605.02149</span>

<span class="sd">        This approach fits the analytical Eisenstein &amp; Hu 1998 (EH98) model</span>
<span class="sd">        to the power spectrum in a chosen k-range, then replaces the BAO</span>
<span class="sd">        wiggle region with the model prediction, blending smoothly between</span>
<span class="sd">        model and data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        logkh : np.ndarray</span>
<span class="sd">            log(k) values.</span>
<span class="sd">        pk_red : np.ndarray</span>
<span class="sd">            Power spectrum values.</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            k values.</span>
<span class="sd">        pk : np.ndarray</span>
<span class="sd">            Power spectrum.</span>
<span class="sd">        kstart, kend : float</span>
<span class="sd">            Fitting range for the EH98 model.</span>
<span class="sd">        krepstart, krepend : float</span>
<span class="sd">            Replacement range for blending model and data.</span>
<span class="sd">        krepwidth : float</span>
<span class="sd">            Width of the tanh activation transition.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth: np.ndarray</span>
<span class="sd">            Smoothed reduced power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">pk_model_eh</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">par</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            EH98 model wrapper for curve_fit</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">par_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">EHclass</span><span class="o">.</span><span class="n">EH98_fit</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">par_prime</span><span class="p">)</span>

        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">pk_red</span><span class="p">)</span>

        <span class="c1"># Initial guess for EH98 parameters</span>
        <span class="n">xini_eh</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.967</span><span class="p">,</span> <span class="mf">6.831</span><span class="p">,</span> <span class="mf">0.4043</span><span class="p">,</span> <span class="mf">55.53</span><span class="p">,</span> <span class="mf">1.5e7</span><span class="p">,</span> <span class="mf">0.96</span><span class="p">]</span>

        <span class="c1"># Fit EH98 model in fitting range</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">kh</span> <span class="o">&lt;</span> <span class="n">kend</span><span class="p">,</span> <span class="n">kh</span> <span class="o">&gt;</span> <span class="n">kstart</span><span class="p">)</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">pk_model_eh</span><span class="p">,</span> <span class="n">kh</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">pk</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">p0</span><span class="o">=</span><span class="n">xini_eh</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

        <span class="c1"># Smooth transition between data and model</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">logkh</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">krepend</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
            <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">logkh</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">krepstart</span><span class="p">))</span> <span class="o">/</span> <span class="n">krepwidth</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Construct the final smoothed power spectrum</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pk_red</span> <span class="o">*</span> <span class="n">activation</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pk_model_eh</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">activation</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1605_2">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1605_2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1605_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Second smoothing method based on ArXiv paper 1605.02149</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Wavenumbers k in units of h/Mpc.</span>
<span class="sd">        pk : np.ndarray</span>
<span class="sd">            Power spectrum values P(k).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth: np.ndarray</span>
<span class="sd">            Smoothed power spectrum P(k).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">pk_model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">pars</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Parametric model for the smoothed matter power spectrum in log-space.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            x : np.ndarray</span>
<span class="sd">                Wavenumbers (k) in units of h/Mpc.</span>
<span class="sd">            *pars : sequence of floats</span>
<span class="sd">                Model parameters in the order:</span>
<span class="sd">                [A, ns, c1, c2, c3, c4, c5, c6, c7]</span>
<span class="sd">                where:</span>
<span class="sd">                    A   : Amplitude scaling factor.</span>
<span class="sd">                    ns  : Spectral index (power-law index).</span>
<span class="sd">                    c1–c4 : Parameters controlling the effective wave number (keff)</span>
<span class="sd">                            and transfer function shape.</span>
<span class="sd">                    c5–c7 : Parameters controlling the broadband boost term Delta(k).</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            np.ndarray</span>
<span class="sd">                Natural log of the modeled power spectrum P(k) evaluated at x.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Overall amplitude of P(k)</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="n">pars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Spectral index (power-law slope)</span>
            <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">,</span> <span class="n">c5</span><span class="p">,</span> <span class="n">c6</span><span class="p">,</span> <span class="n">c7</span> <span class="o">=</span> <span class="n">pars</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># Shape parameters</span>

            <span class="c1"># Check: enforce non-negative shape parameters</span>
            <span class="k">if</span> <span class="n">c1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c3</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c4</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c5</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c6</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c7</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1"># return zeros if parameters are unphysical</span>

            <span class="c1"># Effective wave number scaling</span>
            <span class="n">keff</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">c3</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">c4</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span><span class="p">))</span>

            <span class="c1"># Logarithmic factor for transfer function numerator</span>
            <span class="n">Lk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">e</span> <span class="o">+</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">keff</span><span class="p">)</span>

            <span class="c1"># Empirical denominator term for the transfer function</span>
            <span class="n">Ck</span> <span class="o">=</span> <span class="mf">14.4</span> <span class="o">+</span> <span class="mf">325.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">60.5</span> <span class="o">*</span> <span class="n">keff</span><span class="o">**</span><span class="mf">1.08</span><span class="p">)</span>

            <span class="c1"># Transfer function T(k)</span>
            <span class="n">Tk</span> <span class="o">=</span> <span class="n">Lk</span> <span class="o">/</span> <span class="p">(</span><span class="n">Lk</span> <span class="o">+</span> <span class="n">Ck</span> <span class="o">*</span> <span class="n">keff</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Smooth broadband &quot;boost&quot; term Delta(k)</span>
            <span class="n">Delta</span> <span class="o">=</span> <span class="n">c5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c6</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">c7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">ns</span> <span class="o">*</span> <span class="n">Tk</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">Delta</span><span class="p">))</span>

        <span class="c1"># Initial parameter guesses</span>
        <span class="n">xini</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5e7</span><span class="p">,</span> <span class="mf">0.96</span><span class="p">,</span> <span class="mf">1.967</span><span class="p">,</span> <span class="mf">6.831</span><span class="p">,</span> <span class="mf">0.4043</span><span class="p">,</span> <span class="mf">55.53</span><span class="p">,</span> <span class="mf">0.00425</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">]</span>

        <span class="c1"># Rescale amplitude A so that model matches pk[0] at the first k value</span>
        <span class="n">xini</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">pk_model</span><span class="p">(</span><span class="n">kh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">xini</span><span class="p">))</span> <span class="o">*</span> <span class="n">xini</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Fit the parametric model to log(pk) using non-linear least squares</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">pk_model</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pk</span><span class="p">),</span> <span class="n">p0</span><span class="o">=</span><span class="n">xini</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

        <span class="c1"># Evaluate the smoothed model using the best-fit parameters</span>
        <span class="n">pnw</span> <span class="o">=</span> <span class="n">pk_model</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>

        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pnw</span>
        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_1605_3">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_1605_3">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_1605_3</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bao_left</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">bao_right</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">n_count_wanted</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">kpiv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.03</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Third smoothing method based on ArXiv paper 1605.02149</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Wavenumbers k in units of h/Mpc.</span>
<span class="sd">        pk : np.ndarray</span>
<span class="sd">            Power spectrum values P(k).</span>
<span class="sd">        bao_left: float</span>
<span class="sd">            Left limit of BAO features.</span>
<span class="sd">        bao_right: float</span>
<span class="sd">            Right limit of BAO features.</span>
<span class="sd">        n_count_wanted: int</span>
<span class="sd">            Number of sampling points used for smoothing.</span>
<span class="sd">        kpiv: float</span>
<span class="sd">            Pivot scale.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth : np.ndarray</span>
<span class="sd">            Smoothed power spectrum (log-space values).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1) Mask out the BAO region (only keep k &lt; bao_left or k &gt; bao_right)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">kh</span> <span class="o">&lt;</span> <span class="n">bao_left</span><span class="p">,</span> <span class="n">kh</span> <span class="o">&gt;</span> <span class="n">bao_right</span><span class="p">)</span>

        <span class="c1"># 2) Determine downsampling step size based on target number of points</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_count_wanted</span>

        <span class="c1"># 3) Reduce the number of masked points by skipping most of them</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># 4) Inclusion of the pivot point and the last point</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">kh</span> <span class="o">-</span> <span class="n">kpiv</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># 5) Apply the mask to select subset of k and P(k)</span>
        <span class="n">pk_mask</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">kh_mask</span> <span class="o">=</span> <span class="n">kh</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># 6) Fit cubic spline in log-log space and evaluate on full grid</span>
        <span class="n">pnw</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh_mask</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pk_mask</span><span class="p">))(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh</span><span class="p">))</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pnw</span>

        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_0907">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_0907">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_0907</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bao_left</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">bao_right</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Third smoothing method based on ArXiv paper 0907.1659</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Wavenumbers k in units of h/Mpc.</span>
<span class="sd">        pk : np.ndarray</span>
<span class="sd">            Power spectrum values P(k).</span>
<span class="sd">        bao_left: float</span>
<span class="sd">            Left limit of BAO features.</span>
<span class="sd">        bao_right: float</span>
<span class="sd">            Right limit of BAO features.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth : np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1) Mask points outside the BAO region</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">kh</span> <span class="o">&lt;</span> <span class="n">bao_left</span><span class="p">,</span> <span class="n">kh</span> <span class="o">&gt;</span> <span class="n">bao_right</span><span class="p">)</span>

        <span class="c1"># 2) Define key interpolation nodes</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mf">7e-4</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mf">0.0175</span><span class="p">,</span> <span class="mf">0.262</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">8</span><span class="p">)])</span>

        <span class="c1"># 3) Ensure each node is represented in the mask</span>
        <span class="k">for</span> <span class="n">knod</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">kh</span> <span class="o">-</span> <span class="n">knod</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># 4) Extract masked k and P(k) values</span>
        <span class="n">kh_mask</span> <span class="o">=</span> <span class="n">kh</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="c1"># Multiply by k^1.5 to reduce dynamic range before interpolation</span>
        <span class="n">pk_mask</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">kh_mask</span><span class="o">**</span><span class="mf">1.5</span>

        <span class="c1"># 5) Interpolate in log-log space with a cubic spline</span>
        <span class="c1"># Then exponentiate and divide by k^1.5 to reverse the earlier weighting</span>
        <span class="n">pnw</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh_mask</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pk_mask</span><span class="p">))(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh</span><span class="p">)))</span> <span class="o">/</span> <span class="n">kh</span><span class="o">**</span><span class="mf">1.5</span>
        <span class="p">)</span>
        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">pnw</span>

        <span class="k">return</span> <span class="n">pk_smooth</span></div>


<div class="viewcode-block" id="smoother.smoothing_method_2004">
<a class="viewcode-back" href="../index.html#ShapeFit.smoother.smoothing_method_2004">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_2004</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bao_idx_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">fit_bounds</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">rep_bounds</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">power_even</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">power_odd</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">doplot</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">kmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span>
        <span class="n">kmethod</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">7e-5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing method based on ArXiv paper 2004.10607</span>
<span class="sd">        The smoothing is done using a fast sine transform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Wavenumbers k in units of h/Mpc.</span>
<span class="sd">        pk : np.ndarray</span>
<span class="sd">            Power spectrum values P(k).</span>
<span class="sd">        bao_idx_range : tuple</span>
<span class="sd">            Index range corresponding to BAO features.</span>
<span class="sd">        fit_bounds : tuple</span>
<span class="sd">            Index bounds outside the BAO region used for fitting.</span>
<span class="sd">        rep_bounds : tuple</span>
<span class="sd">            Index bounds for which the DST components are replaced by fitted values.</span>
<span class="sd">        power_even : float</span>
<span class="sd">            Power used to scale even-indexed DST components before fitting.</span>
<span class="sd">        power_odd : float</span>
<span class="sd">            Power used to scale odd-indexed DST components before fitting.</span>
<span class="sd">        doplot : bool</span>
<span class="sd">            Whether to plot intermediate DST components for debugging.</span>
<span class="sd">        kmin : float</span>
<span class="sd">            Minimum wavenumber to include in final smoothed spectrum.</span>
<span class="sd">        kmethod : float</span>
<span class="sd">            Starting wavenumber for DST interpolation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth : np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fitfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">pars</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Polynomial function for fitting DST components in log-space</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">sumres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="p">[</span><span class="n">pars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pars</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">sumres</span>

        <span class="c1"># 1) Define high-resolution k-array for DST interpolation</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">65536</span>
        <span class="n">k_method</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">kmethod</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># 2) Cubic spline interpolation of log(k*P(k))</span>
        <span class="n">pk_method</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh</span> <span class="o">*</span> <span class="n">pk</span><span class="p">),</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">)(</span><span class="n">k_method</span><span class="p">)</span>

        <span class="c1"># 3) Compute DST (type 2) of interpolated log(k*P(k))</span>
        <span class="n">dstres</span> <span class="o">=</span> <span class="n">dst</span><span class="p">(</span><span class="n">pk_method</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">idx_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># 4) Mask regions outside BAO features for fitting</span>
        <span class="n">cut_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx_range</span> <span class="o">&gt;</span> <span class="n">fit_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx_range</span> <span class="o">&lt;</span> <span class="n">bao_idx_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx_range</span> <span class="o">&lt;</span> <span class="n">fit_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_range</span> <span class="o">&gt;</span> <span class="n">bao_idx_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="c1"># 5) Initial guesses for polynomial fits</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e5</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">,</span> <span class="mf">1e0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="c1"># 6) Fit even and odd DST components in log-space</span>
        <span class="n">popt_even</span><span class="p">,</span> <span class="n">pcov_even</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
            <span class="n">fitfunc</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">idx_range</span><span class="p">[</span><span class="n">cut_mask</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">dstres</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">idx_range</span><span class="o">**</span><span class="n">power_even</span><span class="p">)[</span><span class="n">cut_mask</span><span class="p">]),</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">popt_odd</span><span class="p">,</span> <span class="n">pcov_odd</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
            <span class="n">fitfunc</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">idx_range</span><span class="p">[</span><span class="n">cut_mask</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">dstres</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">idx_range</span><span class="o">**</span><span class="n">power_odd</span><span class="p">)[</span><span class="n">cut_mask</span><span class="p">]),</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># 7) Replace DST components in BAO-dominated region using fitted polynomials</span>
        <span class="n">mask_replacement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">idx_range</span> <span class="o">&gt;</span> <span class="n">rep_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx_range</span> <span class="o">&lt;</span> <span class="n">rep_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">replace_even</span> <span class="o">=</span> <span class="p">(</span><span class="n">dstres</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">idx_range</span><span class="o">**</span><span class="n">power_even</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">replace_even</span><span class="p">[</span><span class="n">mask_replacement</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">fitfunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">idx_range</span><span class="p">[</span><span class="n">mask_replacement</span><span class="p">]),</span> <span class="o">*</span><span class="n">popt_even</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">replace_odd</span> <span class="o">=</span> <span class="p">(</span><span class="n">dstres</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">idx_range</span><span class="o">**</span><span class="n">power_odd</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">replace_odd</span><span class="p">[</span><span class="n">mask_replacement</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">fitfunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">idx_range</span><span class="p">[</span><span class="n">mask_replacement</span><span class="p">]),</span> <span class="o">*</span><span class="n">popt_odd</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># 8) Reconstruct full DST array with replaced values</span>
        <span class="n">dstres_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">dstres</span><span class="p">)</span>
        <span class="n">dstres_new</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_even</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">idx_range</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">**</span> <span class="n">power_even</span>
        <span class="n">dstres_new</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_odd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">idx_range</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">**</span> <span class="n">power_odd</span>
        <span class="n">dstres_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dstres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dstres_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dstres</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># 9) Inverse DST to return to log(k*P(k)) space</span>
        <span class="n">log_kPk_new</span> <span class="o">=</span> <span class="n">idst</span><span class="p">(</span><span class="n">dstres_new</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>

        <span class="c1"># 10) Interpolate smoothed log(k*P(k)) back to original kh</span>
        <span class="n">kh_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">kh</span> <span class="o">&gt;</span> <span class="n">kmin</span><span class="p">,</span> <span class="n">kh</span> <span class="o">&lt;</span> <span class="mf">7.0</span><span class="p">)</span>
        <span class="n">log_kPk_interpolated</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k_method</span><span class="p">),</span> <span class="n">log_kPk_new</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh</span><span class="p">[</span><span class="n">kh_mask</span><span class="p">]))</span>

        <span class="c1"># 11) Apply smoothed spectrum, keeping original values outside range</span>
        <span class="n">Pk_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span>
        <span class="n">Pk_smooth</span><span class="p">[</span><span class="n">kh_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_kPk_interpolated</span><span class="p">)</span> <span class="o">/</span> <span class="n">kh</span><span class="p">[</span><span class="n">kh_mask</span><span class="p">]</span>
        <span class="n">Pk_smooth</span><span class="p">[</span><span class="o">~</span><span class="n">kh_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="o">~</span><span class="n">kh_mask</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Pk_smooth</span></div>
</div>



<div class="viewcode-block" id="Likelihood_with_EH">
<a class="viewcode-back" href="../index.html#ShapeFit.Likelihood_with_EH">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Likelihood_with_EH</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General class implementing functions for smoothing the power spectrum</span>

<span class="sd">    smoothing_method_sam : smoothing method used in the original ShapeFit approach</span>

<span class="sd">    smooth_pkm:</span>
<span class="sd">        General function for smoothing the power spectrum using a given method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Likelihood_with_EH.smoothing_method_sam">
<a class="viewcode-back" href="../index.html#ShapeFit.Likelihood_with_EH.smoothing_method_sam">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothing_method_sam</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">k_start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">power_reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span>
        <span class="n">interpkind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;quadratic&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for smoothing the power spectrum based on ArXiv paper 2204.11868</span>
<span class="sd">        The smoothing can be done both in the linear and log domain</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            kh: np.ndarray</span>
<span class="sd">                Wave numbers values.</span>
<span class="sd">            pk: np.ndarray</span>
<span class="sd">                Power spectrum values.</span>
<span class="sd">            k_start: float</span>
<span class="sd">                Initial wave number.</span>
<span class="sd">            power_reduction: str</span>
<span class="sd">                To determine whether to work in log or linear space.</span>
<span class="sd">            interpkind: str</span>
<span class="sd">                Kind of interpolation to perform.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            smoothpk (np.ndarray)</span>
<span class="sd">                smoothed power spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logmode</span> <span class="o">=</span> <span class="n">power_reduction</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span>
        <span class="n">logkh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logmode</span><span class="p">:</span>
            <span class="n">logpk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logpk</span> <span class="o">=</span> <span class="n">pk</span>

        <span class="c1"># Compute derivative of P(k) in chosen domain</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">logpk</span><span class="p">)</span>

        <span class="c1"># Index where k first exceeds k_start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">kh</span> <span class="o">&lt;</span> <span class="n">k_start</span><span class="p">))</span>

        <span class="c1"># Locate local maxima/minima of the gradient</span>
        <span class="n">locmax</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>
        <span class="n">locmin</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">gradient</span><span class="p">)</span>

        <span class="c1"># Find global maximum index in selected region</span>
        <span class="k">if</span> <span class="n">logmode</span><span class="p">:</span>
            <span class="n">glomax</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logpk</span><span class="p">[</span><span class="n">start</span><span class="p">:])</span> <span class="o">+</span> <span class="n">start</span>
            <span class="p">)</span>  <span class="c1"># we ignore everything before start and want the index of the max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glomax</span> <span class="o">=</span> <span class="n">start</span>

        <span class="c1"># Remove extrema before start cutoff</span>
        <span class="n">locmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">locmin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locmin</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">))</span>
        <span class="n">locmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">locmax</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locmax</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">))</span>

        <span class="c1"># Index marking the end of oscillatory region</span>
        <span class="n">commonend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">locmax</span><span class="p">,</span> <span class="n">locmin</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Split into left and right segments depending on glomax position</span>
        <span class="k">if</span> <span class="n">glomax</span> <span class="o">&lt;</span> <span class="n">commonend</span><span class="p">:</span>
            <span class="c1"># &quot;common left part&quot;</span>
            <span class="n">logkhl</span> <span class="o">=</span> <span class="n">logkh</span><span class="p">[:</span><span class="n">glomax</span><span class="p">]</span>
            <span class="n">logpkl</span> <span class="o">=</span> <span class="n">logpk</span><span class="p">[:</span><span class="n">glomax</span><span class="p">]</span>
            <span class="c1"># &quot;common right part&quot;</span>
            <span class="n">logkhr</span> <span class="o">=</span> <span class="n">logkh</span><span class="p">[</span><span class="n">commonend</span><span class="p">:]</span>
            <span class="n">logpkr</span> <span class="o">=</span> <span class="n">logpk</span><span class="p">[</span><span class="n">commonend</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># &quot;common left part&quot;</span>
            <span class="n">logkhl</span> <span class="o">=</span> <span class="n">logkh</span><span class="p">[:</span><span class="n">start</span><span class="p">]</span>
            <span class="n">logpkl</span> <span class="o">=</span> <span class="n">logpk</span><span class="p">[:</span><span class="n">start</span><span class="p">]</span>
            <span class="c1"># &quot;common right part&quot;</span>
            <span class="n">logkhr</span> <span class="o">=</span> <span class="n">logkh</span><span class="p">[</span><span class="n">commonend</span><span class="p">:]</span>
            <span class="n">logpkr</span> <span class="o">=</span> <span class="n">logpk</span><span class="p">[</span><span class="n">commonend</span><span class="p">:]</span>

        <span class="c1"># Build curves for maxima and minima interpolation</span>
        <span class="n">logkhma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">logkhl</span><span class="p">,</span> <span class="n">logkh</span><span class="p">[</span><span class="n">locmax</span><span class="p">],</span> <span class="n">logkhr</span><span class="p">))</span>
        <span class="n">logpkma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">logpkl</span><span class="p">,</span> <span class="n">logpk</span><span class="p">[</span><span class="n">locmax</span><span class="p">],</span> <span class="n">logpkr</span><span class="p">))</span>
        <span class="n">logkhmi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">logkhl</span><span class="p">,</span> <span class="n">logkh</span><span class="p">[</span><span class="n">locmin</span><span class="p">],</span> <span class="n">logkhr</span><span class="p">))</span>
        <span class="n">logpkmi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">logpkl</span><span class="p">,</span> <span class="n">logpk</span><span class="p">[</span><span class="n">locmin</span><span class="p">],</span> <span class="n">logpkr</span><span class="p">))</span>

        <span class="c1"># Interpolators for maxima/minima</span>
        <span class="n">maxfun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">logkhma</span><span class="p">,</span> <span class="n">logpkma</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">interpkind</span><span class="p">)</span>
        <span class="n">minfun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">logkhmi</span><span class="p">,</span> <span class="n">logpkmi</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">interpkind</span><span class="p">)</span>

        <span class="c1"># Average interpolated maxima and minima curves</span>
        <span class="k">if</span> <span class="n">logmode</span><span class="p">:</span>
            <span class="n">smoothpk</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">maxfun</span><span class="p">(</span><span class="n">logkh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">minfun</span><span class="p">(</span><span class="n">logkh</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smoothpk</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxfun</span><span class="p">(</span><span class="n">logkh</span><span class="p">)</span> <span class="o">+</span> <span class="n">minfun</span><span class="p">(</span><span class="n">logkh</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">smoothpk</span></div>


<div class="viewcode-block" id="Likelihood_with_EH.smooth_pkm">
<a class="viewcode-back" href="../index.html#ShapeFit.Likelihood_with_EH.smooth_pkm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth_pkm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">krepstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">krepend</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">krepwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">kstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span>
        <span class="n">kend</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">power_reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span>
        <span class="n">interpkind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;quadratic&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sam&quot;</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">bao_idx_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="mi">120</span><span class="p">,</span> <span class="mi">240</span><span class="p">],</span>
        <span class="n">fit_bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">500</span><span class="p">],</span>
        <span class="n">rep_bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="mi">120</span><span class="p">,</span> <span class="mi">240</span><span class="p">],</span>
        <span class="n">power_even</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.3</span><span class="p">,</span>
        <span class="n">power_odd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span>
        <span class="n">doplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        High-level smoothing function for the power spectrum P(k).</span>
<span class="sd">        The default method is &quot;sam&quot;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kh : np.ndarray</span>
<span class="sd">            Wavenumbers k in units of h/Mpc.</span>
<span class="sd">        pk : np.ndarray</span>
<span class="sd">            Power spectrum values P(k).</span>
<span class="sd">        krepstart, krepend : float</span>
<span class="sd">            Wavenumber k range.</span>
<span class="sd">        krepwidth : float</span>
<span class="sd">            Width parameter for some spline smoothing methods.</span>
<span class="sd">        kstart, kend: float</span>
<span class="sd">            Range of wavenumbers including the BAO features.</span>
<span class="sd">        interpkind: str</span>
<span class="sd">            Interpolation kind.</span>
<span class="sd">        bao_idx_range : list</span>
<span class="sd">            BAO feature index range.</span>
<span class="sd">        fit_bounds : list</span>
<span class="sd">            Bounds for fittingt.</span>
<span class="sd">        rep_bounds : list</span>
<span class="sd">            Bounds for replacment.</span>
<span class="sd">        power_even, power_odd : float</span>
<span class="sd">            Parameters for smoothing_method_2004.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth : np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the input method is not recognized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="n">smoother</span><span class="p">()</span>
        <span class="n">logkh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span>

        <span class="c1"># 1) No smoothing</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pk</span>

        <span class="c1"># 2) Monte-Python method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;MP&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sm</span><span class="o">.</span><span class="n">MP</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kstart</span><span class="p">,</span> <span class="n">kend</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;MP_v2&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sm</span><span class="o">.</span><span class="n">MP_v2</span><span class="p">(</span>
                <span class="n">kh</span><span class="p">,</span>
                <span class="n">pk</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kstart</span><span class="p">,</span> <span class="n">kend</span><span class="p">]),</span>
                <span class="n">factor_left</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;factor_left&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># 3) ShapeFit&#39;s original smoothing method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sam&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;fiducial&quot;</span><span class="p">]:</span>
                <span class="n">pk</span> <span class="o">=</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EHfid&quot;</span><span class="p">]</span>
                <span class="n">pk</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method_sam</span><span class="p">(</span>
                        <span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">power_reduction</span><span class="p">,</span> <span class="n">interpkind</span>
                    <span class="p">)</span>
                    <span class="o">*</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EHfid&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">pk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pk</span> <span class="o">=</span> <span class="p">(</span><span class="n">pk</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EH&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;pk_temp&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EHfid&quot;</span><span class="p">])</span>
                <span class="n">pk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method_sam</span><span class="p">(</span>
                    <span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">power_reduction</span><span class="p">,</span> <span class="n">interpkind</span>
                <span class="p">)</span>
                <span class="n">pk_sam</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EH&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EHfid&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;pk_temp&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">pk_sam</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sam_v2&quot;</span><span class="p">:</span>
            <span class="c1"># Mask for target smoothing range (scaled by hfid)</span>
            <span class="n">mask_replace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">kh</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;hfid&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.005</span><span class="p">,</span> <span class="n">kh</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;hfid&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.5</span>
            <span class="p">)</span>
            <span class="n">eh_cut_fid</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EHfid&quot;</span><span class="p">][</span><span class="n">mask_replace</span><span class="p">]</span>
            <span class="n">eh_cut</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;EH&quot;</span><span class="p">][</span><span class="n">mask_replace</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;fiducial&quot;</span><span class="p">]:</span>
                <span class="n">pk_sam</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">/</span> <span class="n">eh_cut_fid</span>
                <span class="n">pk_sam</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method_sam</span><span class="p">(</span>
                        <span class="n">kh</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;hfid&quot;</span><span class="p">],</span>
                        <span class="n">pk_sam</span><span class="p">,</span>
                        <span class="n">kstart</span><span class="p">,</span>
                        <span class="n">power_reduction</span><span class="p">,</span>
                        <span class="n">interpkind</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="o">*</span> <span class="n">eh_cut_fid</span>
                <span class="p">)</span>
                <span class="n">pk_ret</span> <span class="o">=</span> <span class="n">pk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">pk_ret</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk_sam</span>
                <span class="k">return</span> <span class="n">pk_ret</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pk_sam</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">)(</span><span class="n">kh</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">*</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;rdfac&quot;</span><span class="p">])</span>
                <span class="n">pk_sam</span> <span class="o">=</span> <span class="p">(</span><span class="n">pk_sam</span> <span class="o">/</span> <span class="n">eh_cut</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">options</span><span class="p">[</span><span class="s2">&quot;pk_fid&quot;</span><span class="p">][</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">/</span> <span class="n">eh_cut_fid</span>
                <span class="p">)</span>
                <span class="n">pk_sam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method_sam</span><span class="p">(</span>
                    <span class="n">kh</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;hfid&quot;</span><span class="p">],</span>
                    <span class="n">pk_sam</span><span class="p">,</span>
                    <span class="n">kstart</span><span class="p">,</span>
                    <span class="n">power_reduction</span><span class="p">,</span>
                    <span class="n">interpkind</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">pk_sam</span> <span class="o">=</span> <span class="n">pk_sam</span> <span class="o">*</span> <span class="n">eh_cut</span> <span class="o">/</span> <span class="n">eh_cut_fid</span>
                <span class="n">pk_ret</span> <span class="o">=</span> <span class="n">pk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">pk_ret</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span>
                    <span class="n">kh</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;hfid&quot;</span><span class="p">],</span> <span class="n">pk_sam</span>
                <span class="p">)(</span>
                    <span class="n">kh</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;rdfac&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;hfid&quot;</span><span class="p">]</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">CubicSpline</span><span class="p">(</span>
                    <span class="n">kh</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;pk_temp&quot;</span><span class="p">]</span>
                <span class="p">)(</span>
                    <span class="n">kh</span><span class="p">[</span><span class="n">mask_replace</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;rdfac&quot;</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">pk_ret</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sam_old&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method_sam</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">interpkind</span><span class="p">)</span>

        <span class="c1"># 4) Algorithms implemented from the literature</span>
        <span class="k">if</span> <span class="n">power_reduction</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="n">pk_red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pk_red</span> <span class="o">=</span> <span class="n">pk</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;0907.1659&quot;</span><span class="p">:</span>
            <span class="c1"># Cubic Spline fit</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_0907</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1301.3456&quot;</span><span class="p">:</span>
            <span class="c1"># Correlation function Hankel transform</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1301</span><span class="p">(</span>
                <span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">krepstart</span><span class="o">=</span><span class="n">krepstart</span><span class="p">,</span> <span class="n">krepwidth</span><span class="o">=</span><span class="n">krepwidth</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;univariate&quot;</span><span class="p">:</span>
            <span class="c1"># Fitting univariate spline</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_univariate</span><span class="p">(</span>
                <span class="n">kh</span><span class="p">,</span>
                <span class="n">pk</span><span class="p">,</span>
                <span class="n">krepstart</span><span class="o">=</span><span class="n">krepstart</span><span class="p">,</span>
                <span class="n">krepend</span><span class="o">=</span><span class="n">krepend</span><span class="p">,</span>
                <span class="n">krepwidth</span><span class="o">=</span><span class="n">krepwidth</span><span class="p">,</span>
                <span class="o">**</span><span class="n">options</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1509.02120&quot;</span><span class="p">:</span>
            <span class="c1"># Gaussian smoothing</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1509_1</span><span class="p">(</span>
                <span class="n">logkh</span><span class="p">,</span> <span class="n">pk_red</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">kend</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1509.02120_2&quot;</span><span class="p">:</span>
            <span class="c1">#  B-spline</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1509_2</span><span class="p">(</span>
                <span class="n">logkh</span><span class="p">,</span> <span class="n">pk_red</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">kend</span><span class="p">,</span> <span class="n">krepwidth</span><span class="o">=</span><span class="n">krepwidth</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1509.02120_3&quot;</span><span class="p">:</span>
            <span class="c1"># multi B-Spline</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1509_3</span><span class="p">(</span>
                <span class="n">logkh</span><span class="p">,</span> <span class="n">pk_red</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">kend</span><span class="p">,</span> <span class="n">krepwidth</span><span class="o">=</span><span class="n">krepwidth</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1604.01830&quot;</span><span class="p">:</span>
            <span class="c1"># Polynomial fit</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1604</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">pk_red</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1605.02149&quot;</span><span class="p">:</span>
            <span class="c1"># EH fit</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1605_1</span><span class="p">(</span>
                <span class="n">logkh</span><span class="p">,</span>
                <span class="n">pk_red</span><span class="p">,</span>
                <span class="n">kh</span><span class="p">,</span>
                <span class="n">pk</span><span class="p">,</span>
                <span class="n">kstart</span><span class="p">,</span>
                <span class="n">kend</span><span class="p">,</span>
                <span class="n">krepstart</span><span class="o">=</span><span class="n">krepstart</span><span class="p">,</span>
                <span class="n">krepend</span><span class="o">=</span><span class="n">krepend</span><span class="p">,</span>
                <span class="n">krepwidth</span><span class="o">=</span><span class="n">krepwidth</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1605.02149_2&quot;</span><span class="p">:</span>
            <span class="c1"># EH fit v2</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1605_2</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;1605.02149_3&quot;</span><span class="p">:</span>
            <span class="c1"># Cubic Spline fit</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_1605_3</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;2004.10607&quot;</span><span class="p">:</span>
            <span class="c1"># Correlation function, Fast sine transform</span>
            <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">smoothing_method_2004</span><span class="p">(</span>
                <span class="n">kh</span><span class="p">,</span>
                <span class="n">pk</span><span class="p">,</span>
                <span class="n">bao_idx_range</span><span class="p">,</span>
                <span class="n">fit_bounds</span><span class="p">,</span>
                <span class="n">rep_bounds</span><span class="p">,</span>
                <span class="n">power_even</span><span class="p">,</span>
                <span class="n">power_odd</span><span class="p">,</span>
                <span class="n">doplot</span><span class="p">,</span>
                <span class="n">kmin</span><span class="o">=</span><span class="n">kstart</span><span class="p">,</span>
                <span class="n">kmethod</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;kmethod&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected input: Method  &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

        <span class="c1"># Post-processing: revert domain transformation if needed</span>
        <span class="k">if</span> <span class="n">power_reduction</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">pk_smooth</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">power_reduction</span> <span class="o">==</span> <span class="s2">&quot;EH&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pk_smooth</span> <span class="o">*</span> <span class="n">EHclass</span><span class="o">.</span><span class="n">EH98</span><span class="p">(</span><span class="n">cosmo</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pk_smooth</span></div>
</div>



<div class="viewcode-block" id="cosmology_generator">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">cosmology_generator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for generating and analyzing cosmological power spectra</span>
<span class="sd">    using various smoothing and derivative estimation methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fiducial_cosmo</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">cosmology</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">kmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e-5</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial function including basic setup for computing the power spectrum using any cosmology.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fiducial_cosmo : dict</span>
<span class="sd">            Dictionary of fiducial cosmology parameters for comparison.</span>
<span class="sd">        cosmology : dict</span>
<span class="sd">            Dictionary of cosmology parameters for the target cosmology.</span>
<span class="sd">        kmin : float, optional</span>
<span class="sd">            Minimum wavenumber (in 1/Mpc) for the analysis.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        cosmo : classy.Class or edeclassy.Class</span>
<span class="sd">            Computed cosmology object for target parameters.</span>
<span class="sd">        cosmo_fiducial : classy.Class</span>
<span class="sd">            Computed cosmology object for the fiducial parameters.</span>
<span class="sd">        ks, pks : ndarray</span>
<span class="sd">            Wavenumbers and power spectrum for the target cosmology.</span>
<span class="sd">        ks_out, ks_shift, ks_fid_shift : ndarray</span>
<span class="sd">            Output wavenumber arrays in various shifted/scaled forms.</span>
<span class="sd">        arguments : dict</span>
<span class="sd">            Dictionary of method configurations for smoothing algorithms.</span>
<span class="sd">        derivative_methods : list</span>
<span class="sd">            Available derivative computation methods.</span>
<span class="sd">        processing_methods : list</span>
<span class="sd">            Available power-spectrum post-processing methods to smooth the BAO residuals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Basic setup ---</span>
        <span class="n">z_star</span> <span class="o">=</span> <span class="mf">0.61</span>  <span class="c1"># Reference redshift for power spectrum calculations</span>
        <span class="n">k_max_class</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># Maximum k for class output</span>
        <span class="n">omegancdmfid</span> <span class="o">=</span> <span class="mf">0.00064</span>  <span class="c1"># Fiducial non-CDM density</span>

        <span class="c1"># --- Default ΛCDM cosmology parameters ---</span>
        <span class="n">cosmology_default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="s2">&quot;mPk&quot;</span><span class="p">,</span>
            <span class="s2">&quot;P_k_max_1/Mpc&quot;</span><span class="p">:</span> <span class="n">k_max_class</span><span class="p">,</span>
            <span class="s2">&quot;YHe&quot;</span><span class="p">:</span> <span class="mf">0.24</span><span class="p">,</span>
            <span class="s2">&quot;recombination&quot;</span><span class="p">:</span> <span class="s2">&quot;recfast&quot;</span><span class="p">,</span>
            <span class="s2">&quot;A_s&quot;</span><span class="p">:</span> <span class="mf">2.1e-9</span><span class="p">,</span>  <span class="c1"># Scalar amplitude</span>
            <span class="s2">&quot;tau_reio&quot;</span><span class="p">:</span> <span class="mf">0.0952</span><span class="p">,</span>  <span class="c1"># Optical depth</span>
            <span class="s2">&quot;N_ur&quot;</span><span class="p">:</span> <span class="mf">2.038</span><span class="p">,</span>  <span class="c1"># Effective number of massless neutrinos</span>
            <span class="s2">&quot;N_ncdm&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;deg_ncdm&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;omega_ncdm&quot;</span><span class="p">:</span> <span class="n">omegancdmfid</span><span class="p">,</span>
            <span class="s2">&quot;P_k_max_1/Mpc&quot;</span><span class="p">:</span> <span class="n">k_max_class</span><span class="p">,</span>
            <span class="s2">&quot;k_per_decade_for_pk&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span>
            <span class="s2">&quot;z_max_pk&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># --- EDE (Early Dark Energy) parameters ---</span>
        <span class="n">ded_cosmo_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;scf_potential&quot;</span><span class="p">:</span> <span class="s2">&quot;axion&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n_axion&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s2">&quot;log10_axion_ac&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">3.531</span><span class="p">,</span>
            <span class="s2">&quot;scf_parameters&quot;</span><span class="p">:</span> <span class="s2">&quot;2.72,0.0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;scf_evolve_as_fluid&quot;</span><span class="p">:</span> <span class="s2">&quot;no&quot;</span><span class="p">,</span>
            <span class="s2">&quot;scf_evolve_like_axionCAMB&quot;</span><span class="p">:</span> <span class="s2">&quot;no&quot;</span><span class="p">,</span>
            <span class="s2">&quot;do_shooting&quot;</span><span class="p">:</span> <span class="s2">&quot;yes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;do_shooting_scf&quot;</span><span class="p">:</span> <span class="s2">&quot;yes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;scf_has_perturbations&quot;</span><span class="p">:</span> <span class="s2">&quot;yes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;attractor_ic_scf&quot;</span><span class="p">:</span> <span class="s2">&quot;no&quot;</span><span class="p">,</span>
            <span class="s2">&quot;compute_phase_shift&quot;</span><span class="p">:</span> <span class="s2">&quot;no&quot;</span><span class="p">,</span>
            <span class="s2">&quot;loop_over_background_for_closure_relation&quot;</span><span class="p">:</span> <span class="s2">&quot;yes&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># --- Build cosmology object ---</span>
        <span class="k">if</span> <span class="s2">&quot;fraction_axion_ac&quot;</span> <span class="ow">in</span> <span class="n">cosmology</span><span class="p">:</span>
            <span class="n">cosmo</span> <span class="o">=</span> <span class="n">edeclassy</span><span class="o">.</span><span class="n">Class</span><span class="p">()</span>
            <span class="n">cosmo</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cosmology_default</span><span class="p">)</span>
            <span class="n">cosmo</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ded_cosmo_dict</span><span class="p">)</span>
            <span class="n">cosmo</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cosmology</span><span class="p">)</span>
            <span class="n">cosmo</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span> <span class="o">=</span> <span class="n">cosmo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cosmo</span> <span class="o">=</span> <span class="n">classy</span><span class="o">.</span><span class="n">Class</span><span class="p">()</span>
            <span class="n">cosmo</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cosmology_default</span><span class="p">)</span>
            <span class="n">cosmo</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cosmology</span><span class="p">)</span>
            <span class="n">cosmo</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span> <span class="o">=</span> <span class="n">cosmo</span>

        <span class="c1"># --- Fiducial cosmology ---</span>
        <span class="n">cosmo_fiducial</span> <span class="o">=</span> <span class="n">classy</span><span class="o">.</span><span class="n">Class</span><span class="p">()</span>
        <span class="n">cosmo_fiducial</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cosmology_default</span><span class="p">)</span>
        <span class="n">cosmo_fiducial</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">fiducial_cosmo</span><span class="p">)</span>
        <span class="n">cosmo_fiducial</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cosmo_fiducial</span> <span class="o">=</span> <span class="n">cosmo_fiducial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h_fid</span> <span class="o">=</span> <span class="n">fiducial_cosmo</span><span class="p">[</span><span class="s2">&quot;h&quot;</span><span class="p">]</span>

        <span class="c1"># --- Wavenumber setup ---</span>
        <span class="n">ks_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">kmin</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1001</span><span class="p">)</span>

        <span class="c1"># Radius of sound horizon at drag epoch</span>
        <span class="n">rd_fid_in_Mpc</span> <span class="o">=</span> <span class="n">cosmo_fiducial</span><span class="o">.</span><span class="n">rs_drag</span><span class="p">()</span>
        <span class="n">rd</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">rs_drag</span><span class="p">()</span>

        <span class="c1"># for omegak we used 5e-4</span>
        <span class="n">ks_noshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="n">kmin</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>  <span class="c1"># in Mpc</span>

        <span class="c1"># --- Computing the power spectrum ---</span>
        <span class="n">pks_noshift</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">get_pk_all</span><span class="p">(</span>
            <span class="n">ks_noshift</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z_star</span>
        <span class="p">)</span>  <span class="c1"># get_pk_all will evaluate the power spectrum</span>
        <span class="n">pks_fid_noshift</span> <span class="o">=</span> <span class="n">cosmo_fiducial</span><span class="o">.</span><span class="n">get_pk_all</span><span class="p">(</span><span class="n">ks_noshift</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z_star</span><span class="p">)</span>

        <span class="n">dict_sam</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;EH&quot;</span><span class="p">:</span> <span class="n">EHclass</span><span class="o">.</span><span class="n">EH98</span><span class="p">(</span>
                <span class="n">cosmo</span><span class="p">,</span> <span class="n">ks_noshift</span> <span class="o">*</span> <span class="n">rd_fid_in_Mpc</span> <span class="o">/</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">h</span><span class="p">()</span> <span class="o">/</span> <span class="n">rd</span><span class="p">,</span> <span class="n">z_star</span><span class="p">,</span> <span class="mf">1.0</span>
            <span class="p">),</span>
            <span class="s2">&quot;EHfid&quot;</span><span class="p">:</span> <span class="n">EHclass</span><span class="o">.</span><span class="n">EH98</span><span class="p">(</span><span class="n">cosmo_fiducial</span><span class="p">,</span> <span class="n">ks_noshift</span> <span class="o">/</span> <span class="n">h_fid</span><span class="p">,</span> <span class="n">z_star</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
            <span class="s2">&quot;pk_fid&quot;</span><span class="p">:</span> <span class="n">pks_fid_noshift</span><span class="p">,</span>
            <span class="s2">&quot;pk_temp&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;fiducial&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;hfid&quot;</span><span class="p">:</span> <span class="n">h_fid</span><span class="p">,</span>
            <span class="s2">&quot;rdfac&quot;</span><span class="p">:</span> <span class="n">rd_fid_in_Mpc</span> <span class="o">/</span> <span class="n">rd</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ks</span> <span class="o">=</span> <span class="n">ks_noshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pks</span> <span class="o">=</span> <span class="n">pks_noshift</span>

        <span class="c1"># --- Shifted k arrays ---</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="n">ks_h</span> <span class="o">*</span> <span class="n">h_fid</span> <span class="o">*</span> <span class="n">rd_fid_in_Mpc</span> <span class="o">/</span> <span class="n">rd</span>
        <span class="n">ks_fid</span> <span class="o">=</span> <span class="n">ks_h</span> <span class="o">*</span> <span class="n">h_fid</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span> <span class="o">=</span> <span class="n">ks_h</span>  <span class="c1"># in h/Mpc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ks_shift</span> <span class="o">=</span> <span class="n">ks</span>  <span class="c1"># in Mpc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ks_fid_shift</span> <span class="o">=</span> <span class="n">ks_fid</span>  <span class="c1"># In Mpc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rescale_factor</span> <span class="o">=</span> <span class="n">rd_fid_in_Mpc</span> <span class="o">/</span> <span class="n">rd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pks_fid</span> <span class="o">=</span> <span class="n">pks_fid_noshift</span>

        <span class="c1"># --- BAO scale limits ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_start_bao</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao</span> <span class="o">=</span> <span class="mf">4.5e-1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_start_bao_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_start_bao</span> <span class="o">*</span> <span class="n">rd</span> <span class="o">/</span> <span class="n">rd_fid_in_Mpc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao</span> <span class="o">*</span> <span class="n">rd</span> <span class="o">/</span> <span class="n">rd_fid_in_Mpc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kmpiv</span> <span class="o">=</span> <span class="mf">0.03</span>  <span class="c1"># Pivot scale</span>

        <span class="c1"># --- Method configurations ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;none_v2&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">},</span>
            <span class="s2">&quot;sam_old&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;sam_old&quot;</span><span class="p">},</span>
            <span class="s2">&quot;sam&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;sam&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kstart&quot;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span>
                <span class="s2">&quot;power_reduction&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="n">dict_sam</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;sam_v2&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;sam_v2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kstart&quot;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span>
                <span class="s2">&quot;power_reduction&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="n">dict_sam</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;0907&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;0907.1659&quot;</span><span class="p">,</span>
                <span class="s2">&quot;power_reduction&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;bao_left&quot;</span><span class="p">:</span> <span class="mf">4e-3</span><span class="p">,</span> <span class="s2">&quot;bao_right&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao</span><span class="p">},</span>
            <span class="p">},</span>
            <span class="s2">&quot;1301&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;1301.3456&quot;</span><span class="p">,</span>
                <span class="s2">&quot;power_reduction&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;rlow&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
                    <span class="s2">&quot;rhigh&quot;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
                    <span class="s2">&quot;rfitlow&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
                    <span class="s2">&quot;rfithigh&quot;</span><span class="p">:</span> <span class="mi">300</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="s2">&quot;krepstart&quot;</span><span class="p">:</span> <span class="mf">1e-2</span><span class="p">,</span>
                <span class="s2">&quot;krepwidth&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;1509&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;1509.02120&quot;</span><span class="p">,</span> <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lambdav&quot;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">}},</span>
            <span class="s2">&quot;1509_2&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;1509.02120_2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
                <span class="s2">&quot;kstart&quot;</span><span class="p">:</span> <span class="mf">0.015</span><span class="p">,</span>
                <span class="s2">&quot;kend&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="s2">&quot;krepwidth&quot;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;1509_3&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;1509.02120_3&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kstart&quot;</span><span class="p">:</span> <span class="mf">0.005</span><span class="p">,</span>
                <span class="s2">&quot;kend&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="s2">&quot;krepwidth&quot;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;1604&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;1604.01830&quot;</span><span class="p">},</span>
            <span class="s2">&quot;univariate&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;univariate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;power_reduction&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span>
                    <span class="s2">&quot;kfitlow&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
                    <span class="s2">&quot;kfithigh&quot;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
                    <span class="s2">&quot;w_suppression&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="s2">&quot;krepwidth&quot;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="c1">#&#39;1605&#39;:{&#39;method&#39;:&#39;1605.02149&#39;,&#39;kstart&#39;:0.001,&#39;kend&#39;:0.8},</span>
            <span class="s2">&quot;1605_2&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;1605.02149_2&quot;</span><span class="p">,</span> <span class="s2">&quot;kstart&quot;</span><span class="p">:</span> <span class="mf">5e-5</span><span class="p">,</span> <span class="s2">&quot;kend&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">},</span>
            <span class="s2">&quot;1605_3&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;1605.02149_3&quot;</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;bao_left&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_start_bao</span><span class="p">,</span>
                    <span class="s2">&quot;bao_right&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao</span><span class="p">,</span>
                    <span class="s2">&quot;kpiv&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmpiv</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_fid</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">},</span>
            <span class="s2">&quot;2004&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;2004.10607&quot;</span><span class="p">,</span>
                <span class="s2">&quot;power_reduction&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="s2">&quot;bao_idx_range&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">120</span><span class="p">,</span> <span class="mi">240</span><span class="p">],</span>
                <span class="s2">&quot;fit_bounds&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">500</span><span class="p">],</span>
                <span class="s2">&quot;rep_bounds&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">120</span><span class="p">,</span> <span class="mi">240</span><span class="p">],</span>
                <span class="s2">&quot;power_even&quot;</span><span class="p">:</span> <span class="mf">1.3</span><span class="p">,</span>
                <span class="s2">&quot;power_odd&quot;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>
                <span class="s2">&quot;kstart&quot;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">,</span>
                <span class="s2">&quot;doplot&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;kmethod&quot;</span><span class="p">:</span> <span class="mf">7e-5</span><span class="p">},</span>
            <span class="p">},</span>
            <span class="c1">#&#39;MP&#39;:{&#39;method&#39;:&#39;MP&#39;,&#39;kstart&#39;:self.k_start_bao,&#39;kend&#39;:self.k_end_bao},</span>
            <span class="s2">&quot;MP_v2&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;MP_v2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kstart&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_start_bao</span><span class="p">,</span>
                <span class="s2">&quot;kend&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;factor_left&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">},</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">derivative_methods</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;gradient&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sam&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sam_res&quot;</span><span class="p">,</span>
            <span class="s2">&quot;poly&quot;</span><span class="p">,</span>
            <span class="s2">&quot;steps&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tanh&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tanh_fit&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;savitzky&quot;</span><span class="p">]</span>  <span class="c1"># , &quot;univariate&quot;]</span>

        <span class="n">inputinfos</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative_methods</span><span class="p">}</span>
        <span class="n">inputinfos</span><span class="p">[</span><span class="s2">&quot;sam_res&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;kmin&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>
        <span class="n">inputinfos</span><span class="p">[</span><span class="s2">&quot;steps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;xvals&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.052</span><span class="p">]}</span>
        <span class="n">inputinfos</span><span class="p">[</span><span class="s2">&quot;tanh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;kpiv&quot;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inputinfos</span> <span class="o">=</span> <span class="n">inputinfos</span>

<div class="viewcode-block" id="cosmology_generator.smooth_single">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.smooth_single">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth_single</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nowiggle_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">replace_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">krepstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">krepend</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth the power spectrum for a given method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nowiggle_key : str</span>
<span class="sd">            Key for the smoothing method in self.arguments.</span>
<span class="sd">        replace_options : dict</span>
<span class="sd">            Dictionary of options for the method.</span>
<span class="sd">        krepstart : float</span>
<span class="sd">            Starting k-value.</span>
<span class="sd">        krepend : float</span>
<span class="sd">            Ending k-value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth : np.ndarray</span>
<span class="sd">            Smoothed power spectrum.</span>
<span class="sd">        pk_smooth_fid : np.ndarray</span>
<span class="sd">            Smoothed fiducial power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">leh</span> <span class="o">=</span> <span class="n">Likelihood_with_EH</span><span class="p">()</span>

        <span class="n">arg</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">nowiggle_key</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;options&quot;</span> <span class="ow">in</span> <span class="n">arg</span> <span class="ow">and</span> <span class="n">replace_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arg</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">replace_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">krepstart</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arg</span><span class="p">[</span><span class="s2">&quot;krepstart&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">krepstart</span>
        <span class="k">if</span> <span class="n">krepend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arg</span><span class="p">[</span><span class="s2">&quot;krepend&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">krepend</span>

        <span class="c1"># Fiducial power spectrum smoothing</span>
        <span class="n">pk_smooth_fid</span> <span class="o">=</span> <span class="n">leh</span><span class="o">.</span><span class="n">smooth_pkm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pks_fid</span><span class="p">,</span> <span class="o">**</span><span class="n">arg</span><span class="p">)</span>

        <span class="c1"># Adjust parameters for power spectrum of the target cosmology</span>
        <span class="n">arg_modified</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nowiggle_key</span> <span class="o">==</span> <span class="s2">&quot;sam_v2&quot;</span> <span class="ow">or</span> <span class="n">nowiggle_key</span> <span class="o">==</span> <span class="s2">&quot;sam&quot;</span><span class="p">:</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;fiducial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;pk_temp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk_smooth_fid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">nowiggle_key</span> <span class="o">==</span> <span class="s2">&quot;MP&quot;</span> <span class="ow">or</span> <span class="n">nowiggle_key</span> <span class="o">==</span> <span class="s2">&quot;MP_v2&quot;</span><span class="p">:</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;kstart&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_start_bao_mod</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;kend&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao_mod</span>
        <span class="k">elif</span> <span class="n">nowiggle_key</span> <span class="o">==</span> <span class="s2">&quot;1605_3&quot;</span><span class="p">:</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;bao_left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;bao_left&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_factor</span>
            <span class="p">)</span>  <span class="c1"># self.k_start_bao_mod</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;bao_right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;bao_right&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_factor</span>
            <span class="p">)</span>  <span class="c1"># 2*self.k_end_bao_mod</span>
        <span class="k">elif</span> <span class="n">nowiggle_key</span> <span class="o">==</span> <span class="s2">&quot;0907&quot;</span><span class="p">:</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;bao_left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_start_bao_mod</span> <span class="o">/</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="mf">4e-3</span>
            <span class="n">arg_modified</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;bao_right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_end_bao_mod</span>

        <span class="n">pk_smooth</span> <span class="o">=</span> <span class="n">leh</span><span class="o">.</span><span class="n">smooth_pkm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pks</span><span class="p">,</span> <span class="o">**</span><span class="n">arg_modified</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smooth</span><span class="p">,</span> <span class="n">pk_smooth_fid</span></div>


<div class="viewcode-block" id="cosmology_generator.smooth_and_shift">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.smooth_and_shift">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth_and_shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">replace_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">krepstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">krepend</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth the power spectrum for a given method and apply a rescaling/shift.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Key identifying the smoothing method in `self.arguments`.</span>
<span class="sd">        replace_options : dict</span>
<span class="sd">            Dictionary of options to override in the method configuration.</span>
<span class="sd">        krepstart : float</span>
<span class="sd">            Starting k-value.</span>
<span class="sd">        krepend : float</span>
<span class="sd">            Ending k-value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth_h : ndarray</span>
<span class="sd">            Smoothed and shifted power spectrum for the target cosmology,</span>
<span class="sd">            in units of (h⁻³ Mpc³).</span>
<span class="sd">        pk_smooth_fid_h : ndarray</span>
<span class="sd">            Smoothed and shifted power spectrum for the fiducial cosmology,</span>
<span class="sd">            in units of (h⁻³ Mpc³).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute smoothed spectra for both target and fiducial cosmologies</span>
        <span class="n">pk_smooth</span><span class="p">,</span> <span class="n">pk_smooth_fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_single</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">replace_options</span><span class="o">=</span><span class="n">replace_options</span><span class="p">,</span> <span class="n">krepstart</span><span class="o">=</span><span class="n">krepstart</span><span class="p">,</span> <span class="n">krepend</span><span class="o">=</span><span class="n">krepend</span>
        <span class="p">)</span>

        <span class="c1"># Interpolate the smoothed spectra onto shifted k-grids</span>
        <span class="n">pk_smooth_h</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">CubicSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="p">,</span> <span class="n">pk_smooth</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_shift</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_fid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_factor</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
        <span class="p">)</span>
        <span class="n">pk_smooth_fid_h</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">CubicSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="p">,</span> <span class="n">pk_smooth_fid</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_fid_shift</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_fid</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smooth_h</span><span class="p">,</span> <span class="n">pk_smooth_fid_h</span></div>


<div class="viewcode-block" id="cosmology_generator.smooth_all">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.smooth_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth_all</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth the power spectrum for all methods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth_all : dict</span>
<span class="sd">            Dictionary of smoothed power spectra for all methods.</span>
<span class="sd">        pk_smooth_fid_all : dict</span>
<span class="sd">            Dictionary of smoothed fiducial power spectra for all methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pk_smooth_all</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pk_smooth_fid_all</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">:</span>
            <span class="n">pk_smooth</span><span class="p">,</span> <span class="n">pk_smooth_fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_single</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">pk_smooth_all</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk_smooth</span>
            <span class="n">pk_smooth_fid_all</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk_smooth_fid</span>

        <span class="k">return</span> <span class="n">pk_smooth_all</span><span class="p">,</span> <span class="n">pk_smooth_fid_all</span></div>


<div class="viewcode-block" id="cosmology_generator.smooth_and_shift_all">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.smooth_and_shift_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth_and_shift_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth and shift the power spectrum for all methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Key identifying the smoothing method in `self.arguments`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pk_smooth_all : ndarray</span>
<span class="sd">            Smoothed and shifted power spectra for all methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pk_smooth_and_shift_all</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pk_smooth_fid_and_shift_all</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">:</span>
            <span class="n">pk_smooth</span><span class="p">,</span> <span class="n">pk_smooth_fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_single</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">pk_smooth_and_shift_all</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">CubicSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="p">,</span> <span class="n">pk_smooth</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_shift</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_fid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_factor</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
            <span class="p">)</span>
            <span class="n">pk_smooth_fid_and_shift_all</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">CubicSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="p">,</span> <span class="n">pk_smooth_fid</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_fid_shift</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_fid</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">pk_smooth_and_shift_all</span><span class="p">,</span> <span class="n">pk_smooth_fid_and_shift_all</span></div>


<div class="viewcode-block" id="cosmology_generator.derivative_single">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.derivative_single">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative_single</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nowiggle_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">processing_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">derivative_key</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the derivative for a given combination of</span>
<span class="sd">        smoothing, processing, and derivative methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nowiggle_key : str</span>
<span class="sd">            Key identifying the smoothing method in `self.arguments`.</span>
<span class="sd">        processing_key : str</span>
<span class="sd">            Key identifying the post-processing method in `self.processing_methods`.</span>
<span class="sd">        derivative_key : str</span>
<span class="sd">            Key identifying the derivative method in `self.derivative_methods`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trafxs: np.ndarray</span>
<span class="sd">            Derivative of the power spectrum.</span>
<span class="sd">        info: np.ndarray</span>
<span class="sd">            Information about the derivative.</span>
<span class="sd">        mslope: np.ndarray</span>
<span class="sd">            Slope of the derivative.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1) Smooth and shift both target and fiducial power spectra</span>
        <span class="n">pk_smooth_h</span><span class="p">,</span> <span class="n">pk_smooth_fid_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_and_shift</span><span class="p">(</span><span class="n">nowiggle_key</span><span class="p">)</span>

        <span class="c1"># 2) Compute ratio of target to fiducial spectra</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">pk_smooth_h</span> <span class="o">/</span> <span class="n">pk_smooth_fid_h</span>

        <span class="c1"># 3) Apply preprocessing to the ratio (optional)</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">smooth_ratio</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">smoothmethod</span><span class="o">=</span><span class="n">processing_key</span>
        <span class="p">)</span>

        <span class="c1"># 4) Compute derivative of log(ratio) w.r.t. log(k)</span>
        <span class="n">trafx</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">slope_at_x</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span>
            <span class="n">inputinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputinfos</span><span class="p">[</span><span class="n">derivative_key</span><span class="p">],</span>
            <span class="n">derivmethod</span><span class="o">=</span><span class="n">derivative_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Step 5: Calculate derivative at the pivot scale</span>
        <span class="n">mslope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmpiv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">trafx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trafx</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">mslope</span></div>


<div class="viewcode-block" id="cosmology_generator.derivative_all_for">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.derivative_all_for">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative_all_for</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nowiggle_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">processing_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">replace_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate derivatives for all derivative methods given a smoothing method</span>
<span class="sd">        and a post-processing filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nowiggle_key : str</span>
<span class="sd">            Key identifying the smoothing method in `self.arguments`.</span>
<span class="sd">        processing_key : str</span>
<span class="sd">            Key identifying the post-processing method in `self.processing_methods`.</span>
<span class="sd">        replace_options : dict</span>
<span class="sd">            Dictionary of options to override in the method configuration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mslopes : np.ndarray</span>
<span class="sd">            Array of slope values for all derivative methods.</span>
<span class="sd">        y_values_h : dict</span>
<span class="sd">            Dictionary of smoothed and shifted power spectra for all methods.</span>
<span class="sd">        trafxs : dict</span>
<span class="sd">            Dictionary of derivative values for all methods.</span>
<span class="sd">        infos : dict</span>
<span class="sd">            Mapping from derivative method name to auxiliary output from</span>
<span class="sd">            `slope_maker.slope_at_x`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_values_h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">trafxs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mslopes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivative_methods</span><span class="p">))</span>

        <span class="c1"># 1) Smooth and shift both target and fiducial spectra</span>
        <span class="n">pk_smooth_h</span><span class="p">,</span> <span class="n">pk_smooth_fid_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_and_shift</span><span class="p">(</span>
            <span class="n">nowiggle_key</span><span class="p">,</span> <span class="n">replace_options</span><span class="o">=</span><span class="n">replace_options</span>
        <span class="p">)</span>

        <span class="c1"># 2) Compute the ratio and apply post-processing filter</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">pk_smooth_h</span> <span class="o">/</span> <span class="n">pk_smooth_fid_h</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">smooth_ratio</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">smoothmethod</span><span class="o">=</span><span class="n">processing_key</span>
        <span class="p">)</span>

        <span class="c1"># 3) Loop over all derivative methods and store results</span>
        <span class="k">for</span> <span class="n">ideriv</span><span class="p">,</span> <span class="n">derivative_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivative_methods</span><span class="p">):</span>
            <span class="n">trafx</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">slope_at_x</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span>
                <span class="n">inputinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputinfos</span><span class="p">[</span><span class="n">derivative_key</span><span class="p">],</span>
                <span class="n">derivmethod</span><span class="o">=</span><span class="n">derivative_key</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">mslope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmpiv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">trafx</span><span class="p">)</span>
            <span class="n">trafxs</span><span class="p">[</span><span class="n">derivative_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">trafx</span>
            <span class="n">infos</span><span class="p">[</span><span class="n">derivative_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>
            <span class="n">mslopes</span><span class="p">[</span><span class="n">ideriv</span><span class="p">]</span> <span class="o">=</span> <span class="n">mslope</span>
        <span class="k">return</span> <span class="n">mslopes</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">trafxs</span><span class="p">,</span> <span class="n">infos</span></div>


<div class="viewcode-block" id="cosmology_generator.derivative_all">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.derivative_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute derivatives for all combinations of smoothing, processing,</span>
<span class="sd">        and derivative methods.</span>

<span class="sd">        Atributes:</span>
<span class="sd">        ----------</span>
<span class="sd">        ratios : dict</span>
<span class="sd">            Dictionary of smoothed and shifted power spectra for all methods.</span>
<span class="sd">        derivative_arrays : dict</span>
<span class="sd">            Dictionary of derivative values for all methods.</span>
<span class="sd">        derivative_infos : dict</span>
<span class="sd">            Mapping from derivative method name to auxiliary output from</span>
<span class="sd">            `slope_maker.slope_at_x`.</span>
<span class="sd">        mslopes : np.ndarray</span>
<span class="sd">            Array of slope values for all derivative methods.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_values_h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">trafxs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Preallocate slope array: [derivative_method, processing_method, smoothing_method]</span>
        <span class="n">mslopes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivative_methods</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_methods</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Loop over all smoothing methods</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nowiggle_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">):</span>
            <span class="n">pk_smooth_h</span><span class="p">,</span> <span class="n">pk_smooth_fid_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_and_shift</span><span class="p">(</span><span class="n">nowiggle_key</span><span class="p">)</span>

            <span class="c1"># Loop over all post-processing methods</span>
            <span class="k">for</span> <span class="n">ism</span><span class="p">,</span> <span class="n">processing_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_methods</span><span class="p">):</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">pk_smooth_h</span> <span class="o">/</span> <span class="n">pk_smooth_fid_h</span>

                <span class="c1"># Apply preprocessing to the ratio</span>
                <span class="n">y_values</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">smooth_ratio</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">smoothmethod</span><span class="o">=</span><span class="n">processing_key</span>
                <span class="p">)</span>
                <span class="n">y_values_h</span><span class="p">[(</span><span class="n">processing_key</span><span class="p">,</span> <span class="n">nowiggle_key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_values</span>

                <span class="c1"># Loop over all derivative methods</span>
                <span class="k">for</span> <span class="n">ideriv</span><span class="p">,</span> <span class="n">derivative_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivative_methods</span><span class="p">):</span>
                    <span class="n">trafx</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">slope_at_x</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span>
                        <span class="n">inputinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputinfos</span><span class="p">[</span><span class="n">derivative_key</span><span class="p">],</span>
                        <span class="n">derivmethod</span><span class="o">=</span><span class="n">derivative_key</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">mslope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmpiv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">trafx</span><span class="p">)</span>
                    <span class="n">trafxs</span><span class="p">[(</span><span class="n">processing_key</span><span class="p">,</span> <span class="n">derivative_key</span><span class="p">,</span> <span class="n">nowiggle_key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">trafx</span>
                    <span class="n">infos</span><span class="p">[(</span><span class="n">processing_key</span><span class="p">,</span> <span class="n">derivative_key</span><span class="p">,</span> <span class="n">nowiggle_key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">info</span>
                    <span class="n">mslopes</span><span class="p">[</span><span class="n">ideriv</span><span class="p">][</span><span class="n">ism</span><span class="p">][</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">mslope</span>

        <span class="c1"># Save results to instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratios</span> <span class="o">=</span> <span class="n">y_values_h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivative_arrays</span> <span class="o">=</span> <span class="n">trafxs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivative_infos</span> <span class="o">=</span> <span class="n">infos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mslopes</span> <span class="o">=</span> <span class="n">mslopes</span></div>


<div class="viewcode-block" id="cosmology_generator.derivative_for_method">
<a class="viewcode-back" href="../index.html#ShapeFit.cosmology_generator.derivative_for_method">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative_for_method</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">processing_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">derivative_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">only_arguments</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_info</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">any</span><span class="p">],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">any</span><span class="p">],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        processing_key : str</span>
<span class="sd">            Identifier for the preprocessing method in `self.processing_methods`.</span>
<span class="sd">        derivative_key : str</span>
<span class="sd">            Identifier for the derivative method in `self.derivative_methods`.</span>
<span class="sd">        only_arguments : list[str]</span>
<span class="sd">            Subset of smoothing method keys from `self.arguments` to process.</span>
<span class="sd">            If None (default), all smoothing methods in `self.arguments` are used.</span>
<span class="sd">        add_info : dict, optional</span>
<span class="sd">            Additional options to merge into `self.inputinfos[derivative_key]`</span>
<span class="sd">            before calling `slope_maker.slope_at_x`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mslopes : dict[str, float]</span>
<span class="sd">            Mapping from smoothing method key to slope value at the pivot scale `self.kmpiv`.</span>
<span class="sd">        y_values_h : dict[str, np.ndarray]</span>
<span class="sd">            Mapping from smoothing method key to processed ratio array.</span>
<span class="sd">        trafxs : dict[str, np.ndarray]</span>
<span class="sd">            Mapping from smoothing method key to derivative array</span>
<span class="sd">            (d ln P / d ln k) at each k in `self.ks_out`.</span>
<span class="sd">        infos : dict[str, any]</span>
<span class="sd">            Mapping from smoothing method key to auxiliary output from</span>
<span class="sd">            `slope_maker.slope_at_x`.</span>
<span class="sd">        approxs : dict[str, any]</span>
<span class="sd">            Mapping from smoothing method key to approximation object or data</span>
<span class="sd">            returned by `slope_maker.slope_at_x` when `return_approx=True`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_values_h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">trafxs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mslopes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">approxs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Loop over selected smoothing methods</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nowiggle_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="k">if</span> <span class="p">(</span><span class="n">only_arguments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">only_arguments</span>
        <span class="p">):</span>

            <span class="c1"># 1) Smooth and shift</span>
            <span class="n">pk_smooth_h</span><span class="p">,</span> <span class="n">pk_smooth_fid_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_and_shift</span><span class="p">(</span><span class="n">nowiggle_key</span><span class="p">)</span>

            <span class="c1"># 2) Compute ratio and apply preprocessing</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">pk_smooth_h</span> <span class="o">/</span> <span class="n">pk_smooth_fid_h</span>
            <span class="n">y_values</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">smooth_ratio</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">smoothmethod</span><span class="o">=</span><span class="n">processing_key</span>
            <span class="p">)</span>
            <span class="n">y_values_h</span><span class="p">[</span><span class="n">nowiggle_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_values</span>

            <span class="c1"># 3) Prepare derivative method settings</span>
            <span class="n">inputinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputinfos</span><span class="p">[</span><span class="n">derivative_key</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">add_info</span><span class="p">:</span>
                <span class="n">inputinfo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">add_info</span><span class="p">)</span>

            <span class="c1"># 4) Compute derivative, info, and approximation</span>
            <span class="n">trafx</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">approx</span> <span class="o">=</span> <span class="n">slope_maker</span><span class="o">.</span><span class="n">slope_at_x</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span>
                <span class="n">inputinfo</span><span class="o">=</span><span class="n">inputinfo</span><span class="p">,</span>
                <span class="n">derivmethod</span><span class="o">=</span><span class="n">derivative_key</span><span class="p">,</span>
                <span class="n">return_approx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># 5) Calculate derivative at pivot scale</span>
            <span class="n">mslope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmpiv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_out</span><span class="p">,</span> <span class="n">trafx</span><span class="p">)</span>

            <span class="c1"># Store results</span>
            <span class="n">trafxs</span><span class="p">[</span><span class="n">nowiggle_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">trafx</span>
            <span class="n">infos</span><span class="p">[</span><span class="n">nowiggle_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>
            <span class="n">mslopes</span><span class="p">[</span><span class="n">nowiggle_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mslope</span>
            <span class="n">approxs</span><span class="p">[</span><span class="n">nowiggle_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">approx</span>
        <span class="k">return</span> <span class="n">mslopes</span><span class="p">,</span> <span class="n">y_values_h</span><span class="p">,</span> <span class="n">trafxs</span><span class="p">,</span> <span class="n">infos</span><span class="p">,</span> <span class="n">approxs</span></div>
</div>



<span class="c1"># Fiducial cosmological parameters</span>
<span class="n">h_fid</span> <span class="o">=</span> <span class="mf">0.676</span>  <span class="c1"># Dimensionless Hubble parameter</span>
<span class="n">Omegamfid</span> <span class="o">=</span> <span class="mf">0.31</span>  <span class="c1"># Total matter density parameter</span>
<span class="n">Omegabfid</span> <span class="o">=</span> <span class="mf">0.0481425720388</span>  <span class="c1"># Baryon density parameter</span>

<span class="c1"># Fiducial cosmology dictionary</span>
<span class="n">fiducial_cosmo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;omega_m&quot;</span><span class="p">:</span> <span class="n">Omegamfid</span> <span class="o">*</span> <span class="n">h_fid</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># Total matter density in h^2 units</span>
    <span class="s2">&quot;omega_b&quot;</span><span class="p">:</span> <span class="n">Omegabfid</span> <span class="o">*</span> <span class="n">h_fid</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># Baryon density in h^2 units</span>
    <span class="s2">&quot;h&quot;</span><span class="p">:</span> <span class="n">h_fid</span><span class="p">,</span>  <span class="c1"># Hubble parameter</span>
    <span class="s2">&quot;n_s&quot;</span><span class="p">:</span> <span class="mf">0.97</span><span class="p">,</span>  <span class="c1"># Scalar spectral index</span>
<span class="p">}</span>

<span class="c1"># Dictionary to store different cosmology parameter sets</span>
<span class="n">cosmos</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="generate_cosmology">
<a class="viewcode-back" href="../index.html#ShapeFit.generate_cosmology">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_cosmology</span><span class="p">(</span><span class="n">pars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a cosmology dictionary based on given parameters, update it</span>
<span class="sd">    with given values, and store it in the global `cosmos` dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pars : dict</span>
<span class="sd">        Dictionary of parameters for the cosmology.</span>
<span class="sd">    tag : str</span>
<span class="sd">        Identifier for the cosmology.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a copy of the fiducial cosmology to avoid modifying the original</span>
    <span class="n">cosmology</span> <span class="o">=</span> <span class="n">fiducial_cosmo</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Update the cosmology with parameters provided in `pars`</span>
    <span class="n">cosmology</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pars</span><span class="p">)</span>

    <span class="c1"># If &#39;omega_cdm&#39; is provided, remove &#39;omega_m&#39; to avoid conflicts</span>
    <span class="k">if</span> <span class="s2">&quot;omega_cdm&quot;</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
        <span class="n">cosmology</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;omega_m&quot;</span><span class="p">)</span>

    <span class="c1"># Store the updated cosmology in the global `cosmos` dictionary</span>
    <span class="n">cosmos</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosmology</span></div>



<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Example</span>
<span class="sd">-------</span>
<span class="sd"># Create a new cosmology tagged as &quot;test&quot;</span>
<span class="sd">&gt;&gt;&gt; generate_cosmology({&quot;omega_cdm&quot;: 0.11, &quot;omega_b&quot;: 0.018}, &quot;test&quot;)</span>

<span class="sd"># Choose which cosmological model to work with</span>
<span class="sd">&gt;&gt;&gt; chosen_cosmo_key = &quot;test&quot;</span>
<span class="sd">&gt;&gt;&gt; chosen_cosmo = cosmos[chosen_cosmo_key]</span>

<span class="sd"># Create a cosmology generator object using fiducial and chosen cosmology</span>
<span class="sd">&gt;&gt;&gt; cog = cosmology_generator(fiducial_cosmo, chosen_cosmo)</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ShapeFit</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Katayoon Ghaemi, Nils Schöneberg.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>